//
// Golgi-WiFi v2-08-03
//

#include "libgolgi.h"
/* IS_AUTOGENERATED_SO_ALLOW_AUTODELETE=YES */
/* The previous line is to allow auto deletion */



GolgiException::GolgiException(void){
    initialise(true);
}

GolgiException::GolgiException(bool isSetDefault){
    initialise(isSetDefault);
}

void GolgiException::initialise(bool isSetDefault){
    _corrupt = false;

    _errTextIsSet = isSetDefault;
    _errText = strdup("");

    _errTypeIsSet = isSetDefault;
    _errType = 0;

}

GolgiException *GolgiException::dupe(void){
    GolgiException*dupedInst = new GolgiException();
    if(!dupedInst->decodeFromPayload(this->encode())){
        delete dupedInst;
        dupedInst = (GolgiException *)NULL;
    }
    return dupedInst;
}

GolgiException::~GolgiException(void){
    free((void *)_errText);


}

bool GolgiException::isCorrupt(void){
    return _corrupt;
}

bool GolgiException::errTextIsSet(void){
    return _errTextIsSet;
}

const char *GolgiException::getErrText(void){
    return _errText;
}

void GolgiException::setErrText(const char *val){
    _errTextIsSet = true;
    free((void *)_errText);
    _errText = strdup(val);
}

bool GolgiException::errTypeIsSet(void){
    return _errTypeIsSet;
}

int32_t GolgiException::getErrType(void){
    return _errType;
}

void GolgiException::setErrType(int32_t val){
    _errTypeIsSet = true;
    _errType = val;
}

bool GolgiException::decodeFromPayload(const char *payload){
    GolgiPayload *gp = new GolgiPayload();
    int err = 0;

    gp->addString(payload);

    if(gp->parse() > 0){
        if(err == 0){
            int32_t notfound = 0;
            const char *sval = gp->getString("1", &notfound);
            if(!notfound){
                setErrText(sval);
            }
        }

        if(err == 0){
            int32_t notfound = 0;
            int32_t ival = gp->getInt("2", &notfound);
            if(!notfound){
                setErrType(ival);
            }
        }

    }
    else{
        err = 1;
    }

    delete gp;

    return (err == 0) ? true : false;
}

const char *GolgiException::encode(void){
    return encodeWithPrefix(NULL);
}

const char *GolgiException::encodeWithPrefix(const char *prefix){
    static struct TbxString *dst = NULL;
    const char *realPrefix;

    if(prefix != NULL){
        struct TbxString *str1 = NULL;
        str1 = tbxStrcpy(str1, prefix);
        str1 = tbxStrcat(str1, ".");
        realPrefix = strdup(str1->buf);
        tbxStringRelease(str1);
    }
    else{
        realPrefix = strdup("");
    }

    dst = tbxStrcpy(dst, "");
    if(_errTextIsSet){
        dst = tbxStrcat(dst, realPrefix);
        dst = tbxStrcat(dst, "1: \"");
        dst = tbxStrcat(dst, tbxEscapeString(_errText));
        dst = tbxStrcat(dst, "\"\n");
    }
    if(_errTypeIsSet){
        dst = tbxStrcat(dst, realPrefix);
        dst = tbxStrcat(dst, "2: ");
        dst = tbxStrcat(dst, tbxItos(_errType));
        dst = tbxStrcat(dst, "\n");
    }

    free((void *)realPrefix);

    return dst->buf;
}

/*
 * GolgiAPIImpl.cpp
 *
 *  Created on: Feb 7, 2015
 *      Author: brian
 */


static GolgiAPIImpl *apiImpl = NULL;
int32_t _useTestGolgiServers = 0;

static const char *(*_encrypt_fn)(const char *dst,
                                  const char *payload,
                                  const char **err);

static const char *(*_decrypt_fn)(const char *dst,
                                  const char *payload,
                                  const char **err);

void setCryptoImpl(const char *(*enc)(const char *dst,
                                      const char *payload,
                                      const char **err),
                   const char *(*dec)(const char *src,
                                      const char *payload,
                                      const char **err))
{
    _encrypt_fn = enc;
    _decrypt_fn = dec;
}


GolgiResultSender::GolgiResultSender(GolgiAPIImpl *apiImpl, GolgiMessage *golgiMessage)
{
    this->golgiMessage = golgiMessage->dupe();
    this->apiImpl = apiImpl;
    senderId = strdup(golgiMessage->oa_app_user_id);
    const char *stmp = this->golgiMessage->da_app_user_id;
    this->golgiMessage->da_app_user_id = this->golgiMessage->oa_app_user_id;
    this->golgiMessage->oa_app_user_id = stmp;
}

const char *GolgiResultSender::getSender(void){
    return senderId;
}

void GolgiResultSender::ntlResponse(int32_t rc, const char *rcStr, NTLPayload *payload){
    // Serial.println("sendResult(): " + String(rc) + "/" + String(rcStr));
    delete this;
}

void GolgiResultSender::sendResult(const char *payload){
    // Serial.println("Would send a result with the payload '" + String(payload) + "'");
    this->golgiMessage->msg_type = 1;
    free((void *)this->golgiMessage->payload);
    this->golgiMessage->payload = strdup(payload);

    apiImpl->sendResult(this, golgiMessage);
}

void GolgiResultSender::sendError(int32_t err_type, const char *err_txt){
    // Serial.println("Would send a result with the payload '" + String(payload) + "'");
    this->golgiMessage->msg_type = 2;
    free((void *)this->golgiMessage->payload);
    this->golgiMessage->payload = strdup("");
    this->golgiMessage->err_type = err_type;

    free((void *)this->golgiMessage->err_txt);
    this->golgiMessage->err_txt = strdup(err_txt);

    apiImpl->sendResult(this, golgiMessage);
}


GolgiResultSender::~GolgiResultSender(void){
    delete golgiMessage;
    free((void *)senderId);
}

class GolgiRequestSender:public NTLResponseHandler{
public:
    GolgiRequestSender(GolgiAPIImpl *apiImpl, GolgiMessage *golgiMessage);
    virtual ~GolgiRequestSender();
    void ntlResponse(int32_t rc, const char *rcStr, NTLPayload *payload);
private:
    GolgiAPIImpl *apiImpl;
    GolgiMessage *golgiMessage;
};

GolgiRequestSender::GolgiRequestSender(GolgiAPIImpl *apiImpl, GolgiMessage *golgiMessage)
{
    this->golgiMessage = golgiMessage->dupe();
    this->apiImpl = apiImpl;
    // Serial.println("Would send a request with the payload '" + String(golgiMessage->payload) + "'");
    this->apiImpl->sendRequest(this, golgiMessage);
}

void GolgiRequestSender::ntlResponse(int32_t rc, const char *rcStr, NTLPayload *payload){
    // Serial.println("sendRequest(): " + String(rc) + "/" + String(rcStr));
    delete this;
}


GolgiRequestSender::~GolgiRequestSender(void){
    delete golgiMessage;
}




GolgiAPIImpl *GolgiAPIImpl::getInstance(void){
    return apiImpl;
}

GolgiAPIImpl::GolgiAPIImpl(GolgiNetInterface *netIf, const char *appKey, const char *devKey, const char *instId) {
    apiImpl = this;
    this->ntlConn = new NTLConn(netIf);
    this->ntlConn->setDestination(_useTestGolgiServers ? "gt.o17g.com" : "gp.o17g.com", 20001);
    this->appKey = strdup(appKey);
    this->devKey = strdup(devKey);
    this->instId = strdup(instId);

    golgiSendMsgImpl = new GolgiSendMsgImpl(this);
    ntlConn->addCmdHandler("golgi_send_msg", golgiSendMsgImpl);
    ntlConn->setCredentials(appKey, devKey, instId);
    requestReceiverRoot = TYPE_MALLOC(requestReceiverRoot);
    LLSELFLINK(requestReceiverRoot);
    resultReceiverRoot = TYPE_MALLOC(resultReceiverRoot);
    LLSELFLINK(resultReceiverRoot);

}

const char *genMsgId(){
    static char msgId[32];
    int32_t i;
    for(i = 0; i < 10; i++){
        msgId[i] = random('a', 'z');
    }
    msgId[i] = 0;
    return strdup(msgId);
}

void GolgiAPIImpl::sendGolgiRequest(GolgiResultReceiver *resultReceiver, const char *dst, const char *method, const char *payload){
    char *tmp_payload = NULL;
    GolgiMessage *gm = new GolgiMessage();
    GolgiResultReceiverEntry *gre;

    gm->dev_key = strdup(devKey);
    gm->api_key = strdup(appKey);
    gm->oa_app_user_id = strdup(instId);
    gm->da_app_user_id = strdup(dst);
    gm->message_id = genMsgId();
    gm->msg_type = 0; // MSG_TYPE_REQ
    gm->method = strdup(method);
    gm->err_type = 0;
    gm->err_txt = strdup("");

    {
        const char *crypto_err;
        const char *payload;

        //
        // Crypto Hook
        //
        if(_encrypt_fn){
            crypto_err = NULL;
            const char *e_payload = _encrypt_fn(dst, payload, &crypto_err);
            if(e_payload == NULL){
                //
                // Error handling
                //
                resultReceiver->inboundError(-1, crypto_err);
                payload = NULL;
            }
            else if(strcmp(payload, e_payload) != 0){
                tmp_payload = (char *)malloc(strlen(e_payload) + 1 + 3);
                strcpy(tmp_payload, "{E}");
                strcat(tmp_payload, e_payload);
                payload = tmp_payload;
            }
        }
    }

    if(payload != NULL){
        gm->payload = strdup(payload);

        gre = TYPE_MALLOC(gre);
        gre->receiver = resultReceiver;
        gre->msgId = strdup(gm->message_id);

        LLINSERTB4(resultReceiverRoot, gre);
        
        new GolgiRequestSender(this, gm);
    }

    delete gm;

    if(tmp_payload != NULL){
        free((void *)tmp_payload);
    }

    // golgiSendMsgImpl->sendGolgiRequest(resultReceiver, dst, method, payload);
}

void GolgiAPIImpl::registerReceiver(const char *method, GolgiRequestReceiver *requestReceiver){
    struct GolgiRequestReceiverEntry *rre;

    rre = TYPE_MALLOC(rre);
    rre->method = strdup(method);
    rre->receiver = requestReceiver;
    LLINSERTB4(requestReceiverRoot, rre);
}

void GolgiAPIImpl::incomingRequest(GolgiMessage *msg){
    const char *crypto_err;
    const char *payload;
    struct GolgiRequestReceiverEntry *rre;
    int32_t count;

    // Serial.println("Incoming message: " + String(msg->message_id) + String("/") + String(msg->method));;
    count = 0;
    for(rre = requestReceiverRoot->flink; rre != requestReceiverRoot; rre = rre->flink, count++){
        if(!strcmp(rre->method, msg->method)){
            if(count != 0){
                LLREMOVE(rre);
                LLINSERT(requestReceiverRoot, rre);
            }
            break;
        }
    }

    GolgiResultSender *grs = new GolgiResultSender(this, msg);

    if(rre != requestReceiverRoot){
        // Serial.println("Found request receiver");
        payload = msg->payload;
        //
        // Crypto Hook Here
        //
        if(_decrypt_fn != NULL && !strncmp(payload, "{E}", 3)){
            crypto_err = NULL;
            payload = _decrypt_fn(msg->oa_app_user_id, payload + 3, &crypto_err);
            if(payload == NULL){
                //
                // Problem decrypting
                //
            }
            
        }
        if(payload == NULL){
            grs->sendError(-1, crypto_err != NULL ? crypto_err : "Decryption Failure");
        }
        else{
            rre->receiver->inboundRequest(grs, payload);
        }
    }
    else{
        Serial.println("No receiver registered for: '" + String(msg->method) + "'");
        grs->sendError(-1, "No Receiver");
    }

}

void GolgiAPIImpl::processResult(GolgiMessage *msg, bool isErr){
    const char *crypto_err;
    const char *payload;
    GolgiResultReceiverEntry *rre;

    for(rre = resultReceiverRoot->flink; rre != resultReceiverRoot; rre = rre->flink){
        if(!strcmp(rre->msgId, msg->message_id)){
            break;
        }
    }

    if(rre != resultReceiverRoot){
        LLREMOVE(rre);
        if(isErr){
            rre->receiver->inboundError(msg->err_type, msg->err_txt);
        }
        else{
            payload = msg->payload;
            //
            // Crypto Hook Here
            //
            if(_decrypt_fn != NULL && !strncmp(payload, "{E}", 3)){
                crypto_err = NULL;
                payload = _decrypt_fn(msg->oa_app_user_id, payload + 3, &crypto_err);
                if(payload == NULL){
                    //
                    // Problem decrypting
                    //
                    rre->receiver->inboundError(-1, crypto_err != NULL ? crypto_err : "Decryption Of Response Failed");
                }
                
            }
            if(payload != NULL){
                rre->receiver->inboundResult(payload);
            }
        }
        free((void *)rre->msgId);
        free((void *)rre);
    }


}

void GolgiAPIImpl::incomingResponse(GolgiMessage *msg){
    // Serial.println("Incoming response: " + String(msg->message_id) + String("/") + String(msg->method));;
    processResult(msg, false);

}

void GolgiAPIImpl::incomingError(GolgiMessage *msg){
    Serial.println("Incoming error: " + String(msg->message_id) + String("/") + String(msg->method));;
    processResult(msg, true);
}

void GolgiAPIImpl::sendReqRes(NTLResponseHandler *respHandler,
                              GolgiMessage *msg,
                              bool isResult){
    const char *crypto_err;
    const char *payload;
    char *tmp_payload = NULL;
    NTLPayload *pld = new NTLPayload();
    
    payload = msg->payload;

    //
    // Crypto Hook
    //
    if(_encrypt_fn){
        crypto_err = NULL;
        const char *e_payload = _encrypt_fn(msg->da_app_user_id, payload, &crypto_err);
        if(e_payload == NULL){
            //
            // Error handling
            //
        }
        if(strcmp(payload, e_payload) != 0){
            tmp_payload = (char *)malloc(strlen(e_payload) + 1 + 3);
            strcpy(tmp_payload, "{E}");
            strcat(tmp_payload, e_payload);
            payload = tmp_payload;
        }
    }

    msg->encode(pld, payload);
    // Serial.println("Sending");
    ntlConn->sendCmd("golgi_send_msg", pld, respHandler);

    if(tmp_payload != NULL){
        free((void *)tmp_payload);
    }

    delete pld;
}

void GolgiAPIImpl::sendResult(NTLResponseHandler *respHandler, GolgiMessage *msg){
    sendReqRes(respHandler, msg, true);
}

void GolgiAPIImpl::sendRequest(NTLResponseHandler *respHandler, GolgiMessage *msg){
    sendReqRes(respHandler, msg, false);
}

void GolgiAPIImpl::service(void){
    ntlConn->service();
}


GolgiAPIImpl::~GolgiAPIImpl() {
    // TODO Auto-generated destructor stub
}

/*
 * GolgiDataBlob.cpp
 *
 */


GolgiDataBlob::GolgiDataBlob(){
    this->len = 0;
    this->data = NULL;
}

GolgiDataBlob::GolgiDataBlob(unsigned char *data, int32_t len){
    this->len = len;
    if(this->len == 0){
        this->data = NULL;
    }
    else{
        this->data = (unsigned char *)malloc(len);
        memcpy(this->data, data, len);
    }
}

GolgiDataBlob *GolgiDataBlob::dupe(void){
    return new GolgiDataBlob(data, len);
}

int32_t GolgiDataBlob::getLen(void){
    return len;
}

unsigned char *GolgiDataBlob::getData(void){
    return data;
}
GolgiDataBlob::~GolgiDataBlob(void){
    if(data != NULL){
        free((void *)data);
        data = NULL;
    }
}

/*
 * GolgiMessage.cpp
 *
 *  Created on: Feb 6, 2015
 *      Author: brian
 */



struct FieldRef{
    const char *key;
    int32_t offset;
};

static struct FieldRef stringRefs[] ={
        {"dev_key" , (int32_t)(&((GolgiMessage *)1024)->dev_key) - 1024},
        {"api_key" , (int32_t)(&((GolgiMessage *)1024)->api_key) - 1024},
        {"oa_app_user_id" , (int32_t)(&((GolgiMessage *)1024)->oa_app_user_id) - 1024},
        {"da_app_user_id" , (int32_t)(&((GolgiMessage *)1024)->da_app_user_id) - 1024},
        {"message_id" , (int32_t)(&((GolgiMessage *)1024)->message_id) - 1024},
        {"method" , (int32_t)(&((GolgiMessage *)1024)->method) - 1024},
        {"err_txt" , (int32_t)(&((GolgiMessage *)1024)->err_txt) - 1024},
        {"payload" , (int32_t)(&((GolgiMessage *)1024)->payload) - 1024},
        {NULL, 0},
};

static struct FieldRef intRefs[] ={
        {"msg_type" , (int32_t)(&((GolgiMessage *)1024)->msg_type) - 1024},
        {"err_type" , (int32_t)(&((GolgiMessage *)1024)->err_type) - 1024},
        {NULL, 0},
};

GolgiMessage::GolgiMessage() {
    dev_key = NULL;
    api_key = NULL;
    oa_app_user_id = NULL;
    da_app_user_id = NULL;
    message_id = NULL;
    msg_type = -1;
    method = NULL;
    err_type = -1;
    err_txt = NULL;
    payload = NULL;
    optionRoot = TYPE_MALLOC(optionRoot);
    LLSELFLINK(optionRoot);
}

int32_t GolgiMessage::decode(NTLPayload *payload){
    struct FieldRef *fRef;
    const char *str;
    int32_t err = 0;
    int32_t notFound = 0;
    int32_t val = 0;

    for(int32_t i = 0; stringRefs[i].key != NULL && !err; i++){
        fRef = &stringRefs[i];
        // Serial.print("Lookup: " + String(fRef->key));
        str = payload->getString(fRef->key, &notFound);
        if(notFound){
            // Serial.println(" MISS(1) " + i);
            err = 1;
        }
        else{
            // Serial.println(" HIT");
            ((char **)((char *)this + fRef->offset))[0] = strdup(str);
        }
    }
    for(int32_t i = 0; intRefs[i].key != NULL && !err; i++){
        fRef = &intRefs[i];
        // Serial.print("Lookup: " + String(fRef->key));
        val = payload->getInt(fRef->key, &notFound);
        if(notFound){
            // Serial.println(" MISS");
            err = 1;
        }
        else{
            // Serial.println(" HIT");
            ((int32_t *)((char *)this + fRef->offset))[0] = val;
            // Serial.println("Decoded: " + String(pooky[i].key));
        }
    }

    return (err == 0) ? 1 : 0;
}

void GolgiMessage::encode(NTLPayload *dst, const char *payload){

    dst->addString("dev_key: \"");
    dst->addString(tbxEscapeString(dev_key));
    dst->addString("\"\n");

    dst->addString("api_key: \"");
    dst->addString(tbxEscapeString(api_key));
    dst->addString("\"\n");

    dst->addString("oa_app_user_id: \"");
    dst->addString(tbxEscapeString(oa_app_user_id));
    dst->addString("\"\n");

    dst->addString("da_app_user_id: \"");
    dst->addString(tbxEscapeString(da_app_user_id));
    dst->addString("\"\n");

    dst->addString("message_id: \"");
    dst->addString(tbxEscapeString(message_id));
    dst->addString("\"\n");

    dst->addString("msg_type: ");
    dst->addString(tbxItos(msg_type));
    dst->addString("\n");

    dst->addString("method: \"");
    dst->addString(tbxEscapeString(method));
    dst->addString("\"\n");

    dst->addString("err_type: ");
    dst->addString(tbxItos(err_type));
    dst->addString("\n");

    dst->addString("err_txt: \"");
    dst->addString(tbxEscapeString(err_txt));
    dst->addString("\"\n");

    dst->addString("payload: \"");
    dst->addString(tbxEscapeString(payload));
    dst->addString("\"\n");

#if 0
    struct FieldRef *fRef;

    for(int32_t i = 0; stringRefs[i].key != NULL; i++){
        fRef = &stringRefs[i];
        dst->addString(fRef->key);
        dst->addString(": \"");
        dst->addString(tbxEscapeString(((char **)((char *)this + fRef->offset))[0]));
        dst->addString("\"\n");
    }
    for(int32_t i = 0; intRefs[i].key != NULL; i++){
        fRef = &intRefs[i];
        dst->addString(fRef->key);
        dst->addString(": ");
        dst->addString(tbxItos(((int32_t *)((char *)this + fRef->offset))[0]));
        dst->addString("\n");
    }
#endif

}

void GolgiMessage::encode(NTLPayload *dst){
    encode(dst, this->payload);
}


GolgiMessage *GolgiMessage::dupe(void){
    GolgiMessage *gm = new GolgiMessage();
    gm->dev_key = strdup(dev_key);
    gm->api_key = strdup(api_key);
    gm->oa_app_user_id = strdup(oa_app_user_id);
    gm->da_app_user_id = strdup(da_app_user_id);
    gm->message_id = strdup(message_id);
    gm->msg_type = msg_type;
    gm->method = strdup(method);
    gm->err_type = err_type;
    gm->err_txt = strdup(err_txt);
    gm->payload = strdup(payload);

    struct GmOption *gmo1, *gmo2;
    for(gmo1 = optionRoot->flink; gmo1 != optionRoot; gmo1 = gmo1->flink){
        gmo2 = TYPE_MALLOC(gmo2);
        gmo2->key = strdup(gmo1->key);
        gmo2->val = strdup(gmo1->val);
        LLINSERTB4(gm->optionRoot, gmo2);
    }

    return gm;
}

GolgiMessage::~GolgiMessage() {
    FREE(dev_key);
    FREE(api_key);
    FREE(oa_app_user_id);
    FREE(da_app_user_id);
    FREE(message_id);
    FREE(method);
    FREE(err_txt);
    FREE(payload);
    struct GmOption *gmo;

    while((gmo = optionRoot->flink) != optionRoot){
        LLREMOVE(gmo);
        FREE(gmo->key);
        FREE(gmo->val);
        FREE(gmo);
    }
    FREE(optionRoot);

}

/*
 * GolgiNetInterface.cpp
 *
 */


/*
 * GolgiPayload.cpp
 *
 *  Created on: Feb 9, 2015
 *      Author: brian
 */


GolgiPayload::GolgiPayload() {
}

GolgiPayload::~GolgiPayload() {
}

/*
 * GolgiSendMsgImpl.cpp
 *
 *  Created on: Feb 6, 2015
 *      Author: brian
 */


GolgiSendMsgImpl::GolgiSendMsgImpl(GolgiAPIImpl *apiImpl){
    this->apiImpl = apiImpl;


}

void GolgiSendMsgImpl::ntlRequest(NTLConn *conn, unsigned long tid, NTLPayload *payload){
    int32_t err = 0;
    if(payload == NULL || payload->parse() == 0){
        err = 1;
    }
    else{
        GolgiMessage *gm = new GolgiMessage();
        if(gm->decode(payload) == 0){
            //
            // Failed to decode
            //
            err = 1;
            Serial.println("Failed to decode payload for golgi_send_msg");
            Serial.println("***************************");
            int32_t i = 0;
            const char *lstr;
            while((lstr = payload->readLine()) != NULL){
                Serial.println("[" + String(i) + "]: '" + String(lstr) + "'");
                i++;
            }
            Serial.println("***************************");
            
        }
        else{
            // Serial.println("Successful decode from: " + String(gm->oa_app_user_id));
            // Serial.println ("Message Type:" + String(gm->msg_type));
            // Serial.println ("Payload:" + String(gm->payload));

            if(gm->msg_type == 0){
                //
                // A Request,
                //
                apiImpl->incomingRequest(gm);
            }
            else if(gm->msg_type == 1){
                //
                // A Response
                //
                apiImpl->incomingResponse(gm);
            }
            else if(gm->msg_type == 2){
                //
                // An Error
                //
                apiImpl->incomingError(gm);
            }
            else{
                //
                // No idea what it is, nack it
                //
                err = 1;
            }
            // Serial.println ("**************");
        }
        delete gm;
    }

    if(err){
        conn->sendRsp(tid, 498, "ss_garbled");
    }
    else{
        conn->sendRsp(tid, 300, "Ok");
    }
}



GolgiSendMsgImpl::~GolgiSendMsgImpl() {
    // TODO Auto-generated destructor stub
}

/*
 * NTLConn.cpp
 *
 *  Created on: Feb 4, 2015
 *      Author: brian
 */



class NopSender:public NTLResponseHandler{
public:
    NopSender(NTLConn *ntlConn);
    void service();
    void ntlResponse(int32_t rc, const char *rcStr, NTLPayload *payload);
    virtual ~NopSender();
private:
    NTLConn *ntlConn;
    unsigned long lastNop;
    bool nopInFlight;
};

NopSender::NopSender(NTLConn *ntlConn){
    this->ntlConn = ntlConn;
    lastNop = millis();
    nopInFlight = false;
}

void NopSender::ntlResponse(int32_t rc, const char *rcStr, NTLPayload *payload){
    char *strTmp = (char *)malloc(16);
    nopInFlight = false;
    Serial.println(String("Nop Response ") + String(rc) + String("/") + String(rcStr) + String("   [") + String((int32_t)strTmp, HEX) + String("]"));
    free(strTmp);
}

void NopSender::service(void){
    // Serial.println("SVC");
    if(!nopInFlight){
        unsigned long elapsed = millis() - lastNop;
        if(elapsed > 10000){
            nopInFlight = true;
            lastNop = millis();
            Serial.print(">>>NOP: ");
            ntlConn->sendCmd("nop", this);
        }
    }
}
NopSender::~NopSender(void){
}

class GolgiRegistrar:public NTLResponseHandler{
public:
    GolgiRegistrar(NTLConn *ntlConn, const char *devKey, const char *appKey, const char *instId);
    void ntlResponse(int32_t rc, const char *rcStr, NTLPayload *payload);
    virtual ~GolgiRegistrar();
private:
    NTLConn *ntlConn;
};

GolgiRegistrar::GolgiRegistrar(NTLConn *ntlConn, const char *devKey, const char *appKey, const char *instId){
    this->ntlConn = ntlConn;

    NTLPayload *pld = new NTLPayload();
    pld->addString("dev_key: \"");
    pld->addString(tbxEscapeString(devKey));
    pld->addString("\"\n");

    pld->addString("api_key: \"");
    pld->addString(tbxEscapeString(appKey));
    pld->addString("\"\n");

    pld->addString("app_user_id: \"");
    pld->addString(tbxEscapeString(instId));
    pld->addString("\"\n");
    pld->addString("push_id: \"\"\n");
    pld->addString("device_type: 0\n");
    pld->addString(".\n");


    ntlConn->sendCmd("golgi_register", pld, this);
    Serial.println("Registration away");
    delete pld;
}

void GolgiRegistrar::ntlResponse(int32_t rc, const char *rcStr, NTLPayload *payload){

    Serial.println(String("Golgi Registration Response ") + String(rc) + String("/") + String(rcStr));
    ntlConn = NULL;

    delete this;
}

GolgiRegistrar::~GolgiRegistrar(){
}

NTLConn::NTLConn(GolgiNetInterface *netIf){
    this->netIf = netIf;
    this->appKey = NULL;
    this->devKey = NULL;
    this->instId = NULL;
    haveCredentials = false;
    lbufSz = 80;
    lbufWr = 0;
    lbuf = (char *)malloc(lbufSz);
    bannerSeen = false;
    golgiRegistered = false;
    disconnectSeen = false;
    discoTime = 0;
    recoCount = 0;
    if(netIf->needsNops()){
        nopSender = new NopSender(this);
    }
    else{
        nopSender = NULL;
    }
    nextTid = 4096; // Device transactions IDs are always even
    resHandlerList = TYPE_MALLOC(resHandlerList);
    LLSELFLINK(resHandlerList);
    reqHandlerList = TYPE_MALLOC(reqHandlerList);
    LLSELFLINK(reqHandlerList);
    payload = NULL;
    currentLine = NULL;

}

void NTLConn::setCredentials(const char *appKey, const char *devKey, const char *instId){
    if(!haveCredentials){
        haveCredentials = true;
        this->appKey = strdup(appKey);
        this->devKey = strdup(devKey);
        this->instId = strdup(instId);
        if(bannerSeen && !disconnectSeen){
            new GolgiRegistrar(this, devKey, appKey, instId);
        }
    }
}

void NTLConn::reconnect(){
    recoTime = millis();
    Serial.print("**** Connect to: '");
    Serial.println(String(host) + String("/") + String(port) + String("' **** ") + String(recoCount++));

    if(netIf->connect(host, port)){
        bannerSeen = false;
        golgiRegistered = false;
        lbufWr = 0;
        disconnectSeen = false;
    }
    else{
        disconnectSeen = true;
        discoTime = millis();
    }
}

void NTLConn::setDestination(const char *host, int32_t port){
    this->host = host;
    this->port = port;
}

bool NTLConn::connect(const char *host, int32_t port)
{
    if(netIf->connected()){
        return false;
    }
    else{
        this->host = host;
        this->port = port;
        reconnect();
        return netIf->connected();
    }
}

void NTLConn::sendReqOTW(unsigned long tid, const char *data){
    // Serial.println("TID: " + String(tbxToHex(tid)));

    if(netIf->packetized()){
        netIf->sendReq(tid, data);
    }
    else{
        netIf->write(tbxToHex(tid));
        netIf->write(data);
    }
}

void NTLConn::sendRspOTW(unsigned long tid, const char *data){
    if(netIf->packetized()){
        netIf->sendRes(tid, data);
    }
    else{
        netIf->write(tbxToHex(tid));
        netIf->write(data);
    }
}

void NTLConn::processLine(){
    struct NtlResHandlerEntry *rhe;
    const char *c1, *c2, *rcStr;
    unsigned long tid;
    int32_t rc;

    // Serial.print("Line: '");
    // Serial.println(String(lbuf) + String("'"));

    if(payload != NULL){
        payload->addString(lbuf);
        payload->addChar('\n');
        if(!payload->isComplete()){
            return;
        }
        c1 = currentLine;
    }
    else if(lbuf[strlen(lbuf) - 1] == '\\'){
        // Serial.println("Start of payload");
        payload = new NTLPayload();
        lbuf[strlen(lbuf) - 1] = 0;
        currentLine = strdup(lbuf);
        return;
    }
    else{
        //
        // Normal line
        //
        c1 = lbuf;
    }

    c1 = tbxEatWhite(c1);

    if(!bannerSeen){
        rc = tbxGet3DigitCode(c1);
        Serial.print("Banner Code: ");
        Serial.println(rc);
        bannerSeen = true;
        if(rc >= 200 && rc <= 399 && haveCredentials){
            //
            // Positive banner, send registration
            //
            new GolgiRegistrar(this, devKey, appKey, instId);
        }
    }
    else{
        if(!strncmp(c1, "0x", 2) || !strncmp(c1, "0X", 2)){
            tid = 0;
            c1 += 2;
            c1 = tbxFromHex(&tid, c1);
            // Serial.println(String("TID: ") + String(tid));
            c1 = tbxEatWhite(c1);
            rc = tbxGet3DigitCode(c1);
            if(rc > 0){
                //
                // A Response
                //
                c1 = tbxEatWhite(c1 + 3);

                for(rhe = resHandlerList->flink; rhe != resHandlerList; rhe = rhe->flink){
                    if(rhe->tid == tid){
                        LLREMOVE(rhe);
                        break;
                    }
                    else{
                        // Serial.println("Miss: " + String(rhe->tid));
                    }
                }
                if(rhe == resHandlerList){
                    //
                    // Response to something we know nothing about, eat it.
                    //
                }
                else{
                    //
                    // Ok, we have a handler, lets scoop out rcStr
                    //
                    c2 = tbxEatBlack(c1);
                    rcStr = tbxSubStrdup(c1, c2);
                    rhe->responseHandler->ntlResponse(rc, rcStr, payload);
                    free((void *)rcStr);
                    free(rhe);
                }
            }
            else{
                //
                // A Request
                //
                int32_t lineCount;
                if(payload == NULL){
                    lineCount = -1;
                }
                else{
                    lineCount = payload->lineCount();
                    // Serial.println("There are " + String(lineCount) + " lines in the payload");
                    if(lineCount > 0){
                        payload->parse();
                    }
                }

                c2 = tbxEatBlack(c1);
                const char *cmd = tbxSubStrdup(c1, c2);

                struct NtlReqHandlerEntry *rhe;
                int32_t count = 0;
                int32_t found = 0;
                for(rhe = reqHandlerList->flink; rhe != reqHandlerList; rhe = rhe->flink, count++){
                    if(!strcmp(rhe->cmd, cmd)){
                        if(count != 0){
                            LLREMOVE(rhe);
                            LLINSERT(reqHandlerList, rhe);
                        }
                        found = 1;
                        rhe->requestHandler->ntlRequest(this, tid, payload);
                        break;
                    }
                }
                if(!found){
                    Serial.println("Unknown request with TID: " + String(tid) + String(" (") + tbxToHex(tid) + ") and remaining text: '" + cmd + "' with " + String(lineCount) + " lines of payload");
                    sendRspOTW(tid, " 499 Unknown command\n");
                }
                free((void *)cmd);

            }
        }
    }
    if(currentLine){
        free(currentLine);
        currentLine = NULL;
        if(payload){
            delete payload;
            payload = NULL;
        }
    }
}

void NTLConn::service(){
    char chBuf[32];
    int32_t avail;

    if(netIf->needsNops()){
        nopSender->service();
    }
    if(netIf->connected()){
        while((avail = netIf->available()) > 0){
            if(avail > (int32_t)sizeof(chBuf)){
                avail = sizeof(chBuf);
            }
            avail = netIf->read(chBuf, avail);
            for(int32_t i = 0; i < avail; i++){
                char ch = chBuf[i];
                lbuf[lbufWr++] = ch;
                if(lbufWr == lbufSz){
                    char *newBuf = (char *)malloc(lbufSz + 16);
                    for(int32_t i = 0; i < lbufSz; i++){
                        newBuf[i] = lbuf[i];
                    }
                    lbufSz += 16;
                    free(lbuf);
                    lbuf = newBuf;
                }
                if(ch == '\r' || ch == '\n'){
                    lbuf[lbufWr-1] = 0;
                    //
                    // We have a line;
                    //
                    processLine();
                    lbufWr = 0;
                    lbuf[lbufWr] = 0;
                }
            }
        }
    }
    else if(!disconnectSeen){
        disconnectSeen = true;
        recoTime = millis() - recoTime;
        int32_t secs = recoTime / 1000;
        int32_t tenths = (recoTime % 1000)/100;
        Serial.println(String("**** DISCONNECT after ") + String(secs) + String(".") + String(tenths) + String("s ****"));
        // Serial.print("Call stop(): ");
        netIf->stop();
        // Serial.println("DONE");
        discoTime = millis();
        struct NtlResHandlerEntry *rhe;

        // Serial.println("Free resHandlerList");
        while((rhe = resHandlerList->flink) != resHandlerList){
            LLREMOVE(rhe);
            rhe->responseHandler->ntlResponse(496, "Client Side Closed", NULL);
            free(rhe);
        }
        Serial.println("Done");

    }
    else if((millis() - discoTime) > 1000){
        reconnect();
    }
}

void NTLConn::sendCmd(const char *cmd, NTLPayload *cmdPayload, NTLResponseHandler *rspHandler){
    static struct TbxString *str = NULL;

    if(!netIf->connected()){
        rspHandler->ntlResponse(-1, "Not Connected", NULL);
    }
    else{
        unsigned long tid = nextTid;
        nextTid += 2; // Device transactions IDs are always even
        struct NtlResHandlerEntry *rhe = (NtlResHandlerEntry *)malloc(sizeof(*rhe));
        rhe->tid = tid;
        rhe->responseHandler = rspHandler;
        // Serial.println(String("SEND: '") + data + String("'"));

        LLINSERTB4(resHandlerList, rhe);

        str = tbxStrcpy(str, " ");
        str = tbxStrcat(str, cmd);
        
        if(cmdPayload == NULL){
            str = tbxStrcat(str, "\n");
        }
        else{
            str = tbxStrcat(str, "\\\n");
            const char *lstr;
            // Serial.println("************");
            while((lstr = cmdPayload->readLine()) != NULL){
                // Serial.println(String("LINE: '") + String(lstr) + "'");
                str = tbxStrcat(str, lstr);
                str = tbxStrcat(str, "\n");
            }
            // Serial.println("************");
            str = tbxStrcat(str, ".\n");
        }
        sendReqOTW(tid, str->buf);
    }
}

void NTLConn::sendCmd(const char *cmd, NTLResponseHandler *rspHandler){
    sendCmd(cmd, NULL, rspHandler);
}

void NTLConn::sendRsp(unsigned long tid, int32_t rc, const char *rcStr, NTLPayload *payload){
    static struct TbxString *str = NULL;
    
    if(netIf->connected()){
        str = tbxStrcpy(str, " ");
        str = tbxStrcat(str, tbxItos(rc));
        str = tbxStrcat(str, " ");
        str = tbxStrcat(str, rcStr);
        
        if(payload == NULL || payload->lineCount() <= 0){
            str = tbxStrcat(str, "\n");
        }
        else{
            str = tbxStrcat(str, "\\\n");
            const char *line;
            while((line = payload->readLine()) != NULL){
                if(line[0] == '.'){
                    str = tbxStrcat(str, ".");
                }
                str = tbxStrcat(str, line);
                str = tbxStrcat(str, "\n");
            }
            str = tbxStrcat(str, ".\n");
        }
        sendRspOTW(tid, str->buf);
    }
}

void NTLConn::sendRsp(unsigned long tid, int32_t rc, const char *rcStr){
    sendRsp(tid, rc, rcStr, NULL);
}

void NTLConn::addCmdHandler(const char *cmd, NTLRequestHandler *reqHandler){
    struct NtlReqHandlerEntry *rhe;
    rhe = TYPE_MALLOC(rhe);
    rhe->cmd = strdup(cmd);
    rhe->requestHandler = reqHandler;
    LLINSERTB4(reqHandlerList, rhe);
}



NTLConn::~NTLConn() {
    struct NtlResHandlerEntry *resH;
    while((resH = resHandlerList->flink) != resHandlerList){
        resH->responseHandler->ntlResponse(496, "Closed", NULL);
        LLREMOVE(resH);
        free(resH);
    }
    free(resH);

    struct NtlReqHandlerEntry *reqH;
    while((reqH = reqHandlerList->flink) != reqHandlerList){
        LLREMOVE(reqH);
        free(reqH);
    }
    free(reqH);
    free(lbuf);
}

/*
 * NTLPayload.cpp
 *
 *  Created on: Feb 4, 2015
 *      Author: brian
 */



NTLPayload::NTLPayload() {
        bufWr = 0;
        bufRd = 0;
        bufSize = 0;
        buf = (char *)"";
        lines = 0;
        bufSize = 16;
        buf = (char *)malloc(bufSize);
        buf[0] = 0;
        wasEol = true;
        dotEscaped = false;
        complete = false;
        tvRoot = NULL;
}

bool NTLPayload::isComplete(void)
{
        return complete;
}

int32_t NTLPayload::lineCount(void){
    return lines;
}

const char *NTLPayload::charData(void){
    return buf;
}

void NTLPayload::addChar(char ch){
        if(complete){
                // Never add anything else
        }
        else if(wasEol && (ch == '\n' || ch == '\r')){
            if(dotEscaped){
                //
                // Actually this is complete
                //
                complete = true;
            }
                // Ignore blank lines
        }
        else if(wasEol && ch == '.'){
                dotEscaped = 1;
        }
        else{
            wasEol = false;
                buf[bufWr++] = ch;
                llen++;
                if(bufWr == bufSize){
                        char *newBuf = (char *)malloc(bufSize + 128);
                        for(int32_t i = 0; i < bufSize; i++){
                                newBuf[i] = buf[i];
                        }
                        bufSize += 128;
                        free(buf);
                        buf = newBuf;
                }
                if(ch == '\n' || ch == '\r'){
                        buf[bufWr-1] = 0;
                        lines++;
                        if(dotEscaped && llen == 1){
                                complete = true;
                                bufWr--;
                        }
                        wasEol = true;
                        llen = 0;
                        dotEscaped = false;
                        llen = 0;
                }
                buf[bufWr] = 0;
        }
}

void NTLPayload::addString(const char *string)
{
        while(*string){
                addChar(*string++);
        }
}

const char *NTLPayload::readLine(void){
    const char *lstr = NULL;
    if(lines > 0){
        lstr = buf + bufRd;
        lines--;
        bufRd += strlen(lstr) + 1;
    }

    return lstr;
}

struct TvPair *NTLPayload::locateTag(const char *tag){
    struct TvPair *tvp;
    if(tvRoot != NULL){
        if(tvRoot->flink == tvRoot){
            // Serial.println("tvRoot is empty");
        }
        for(tvp = tvRoot->flink; tvp != tvRoot; tvp = tvp->flink){
            // Serial.println("Compare '" + String("'") + tvp->tag + String("' and '") + tag + String("'"));
            if(!strcmp(tag, tvp->tag)){
                LLREMOVE(tvp);
                LLINSERTB4(tvRoot, tvp);
                return tvp;
            }
        }
    }
    else{
        // Serial.println("tvRoot is NULL");
    }
    return NULL;
}


const char *NTLPayload::getString(const char *tag, int32_t *notFound){
    const char *result = NULL;
    const char *c1, *c2, *raw;
    struct TvPair *tvp;
    // Serial.println("Asked to lookup " + String(tag));
    if((tvp = locateTag(tag)) != NULL){
        c1 = tvp->value;
        if(*c1 == '"'){
            c2 = c1 + strlen(c1) - 1;
            while(c1 != c1 && *c2 != '"'){
                c2--;
            }
            if(c2 != c1){
                raw = tbxSubStrdup(c1 + 1, c2);
                result = tbxDeEscapeString(raw);
                free((void *)raw);
            }
        }
    }
    else{
        // Serial.println("Failed to locate it " + String(tag));
    }

    if(result == NULL){
        *notFound = 1;
    }
    else{
        *notFound = 0;
    }

    return result;
}

unsigned char *NTLPayload::getData(const char *tag, int32_t *notFound, int32_t *lenPtr){
    unsigned char *result = NULL;
    const char *c1, *c2, *b64;
    int32_t len;
    struct TvPair *tvp;
    // Serial.println("Asked to lookup " + String(tag));
    if((tvp = locateTag(tag)) != NULL){
        c1 = tvp->value;
        if(*c1 == '['){
            c2 = c1 + strlen(c1) - 1;
            while(c1 != c1 && *c2 != ']'){
                c2--;
            }
            if(c2 != c1){
                //
                // Bingo
                //
                b64 = tbxSubStrdup(c1 + 1, c2);
                result = (unsigned char *)malloc((strlen(b64)/4) * 3 + 3);
                len = b64_decode(result, b64);
                if(len >= 0){
                    *lenPtr = len;
                }
                else{
                    free((void *)result);
                    result = NULL;
                }
                free((void *)b64);
            }
        }
    }
    else{
        // Serial.println("Failed to locate it " + String(tag));
    }

    if(result == NULL){
        *notFound = 1;
    }
    else{
        *notFound = 0;
    }

    return result;
}

int32_t NTLPayload::getInt(const char *tag, int32_t *notFound){
    int32_t result = 0;
    struct TvPair *tvp;
    // Serial.println("Asked to lookup " + String(tag));
    if((tvp = locateTag(tag)) != NULL){
        result = atoi(tvp->value);
        // Serial.println("Found: " + String(tag) + String("   ") + String(result));
        *notFound = 0;
    }
    else{
        // Serial.println("Failed to find: " + String(tag));
        *notFound = 1;
    }

    return result;
}

double NTLPayload::getDouble(const char *tag, int32_t *notFound){
    double result = 0.0;
    struct TvPair *tvp;
    // Serial.println("Asked to lookup " + String(tag));
    if((tvp = locateTag(tag)) != NULL){
        result = tbxStod(tvp->value, notFound);
    }
    else{
        // Serial.println("Failed to find: " + String(tag));
        *notFound = 1;
    }

    return result;
}

const char *NTLPayload::getNestedPayload(const char *prefix){
    static char *staticBuf = NULL;
    struct TbxString *str = NULL;
    struct TvPair *tvp;
    char *pfxWdot = (char *)malloc(strlen(prefix) + 2);

    strcpy(pfxWdot, prefix);
    strcat(pfxWdot, ".");

    int32_t pfxLen = strlen(pfxWdot);

    str = tbxStrcat(str, "");

    if(tvRoot != NULL){
        if(tvRoot->flink == tvRoot){
            // Serial.println("tvRoot is empty");
        }
        for(tvp = tvRoot->flink; tvp != tvRoot; tvp = tvp->flink){
            // Serial.println("Compare '" + String("'") + tvp->tag + String("' and '") + tag + String("'"));
            if(!strncmp(tvp->tag, pfxWdot, pfxLen)){
                str = tbxStrcat(str, tvp->tag + pfxLen);
                str = tbxStrcat(str, ": ");
                str = tbxStrcat(str, tvp->value);
                str = tbxStrcat(str, "\n");
            }
        }
    }

    free(pfxWdot);

    if(staticBuf != NULL){
        free(staticBuf);
    }
    staticBuf = strdup(str->buf);

    tbxStringRelease(str);

    return staticBuf;
}




int32_t NTLPayload::parse(void){
    struct TvPair *tvp;
    int32_t count;
    const char *c1, *c2, *c3;
    char *tag;
    char *val;
    c1 = buf;

    if(tvRoot != NULL){
        count = 0;
        for(tvp = tvRoot->flink; tvp != tvRoot; tvp = tvp->flink){
            count++;
        }
    }
    else{
        tvRoot = (TvPair *)malloc(sizeof (*tvRoot));
        LLSELFLINK(tvRoot);

        count = 0;

        for(c1 = buf; *c1 != 0; c1 += strlen(c1) + 1){
            c1 = tbxEatWhite(c1);
            c2 = tbxEatBlack(c1);
            for(c3 = c1; c3 != c2; c3++){
                if(*c3 == ':'){
                    break;
                }
            }
            if(c3 != c2){
                //
                // Found :
                //
                tag = tbxSubStrdup(c1, c3);
                c1 = tbxEatWhite(c3+1);
                val = strdup(c1);

                tvp = (struct TvPair *)malloc(sizeof(*tvp));
                tvp->tag = tag;
                tvp->value = val;
                LLINSERTB4(tvRoot, tvp);
                count++;
            }
        }
    }

    return count;
}

NTLPayload::~NTLPayload() {
    if(bufSize > 0){
        free(buf);
    }
    if(tvRoot != NULL){
        struct TvPair *tvp;
        while((tvp = tvRoot->flink) != tvRoot){
            LLREMOVE(tvp);
            free((void *)tvp->tag);
            free((void *)tvp->value);
            free((void *)tvp);
        }
        free(tvRoot);
    }
}

/*
 * tbx.c
 *
 *  Created on: Feb 6, 2015
 *      Author: brian
 */


void tbxFree(void *addr){
    if(addr != NULL){
        free(addr);
    }
}

const char *tbxToHex(unsigned long val){
    static char hexLut[16] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};
    static char result[12];
    char *c1 = result;
    *c1++ = '0';
    *c1++ = 'x';
    c1 += 8;
    *c1 = 0;
    for(int32_t i = 0; i < 8; i++){
        *--c1 = hexLut[val & 0xf];
        val >>= 4;
    }

    return result;
}

char *tbxFromHex (unsigned long *dst, const char *hex){
    unsigned long val = 0;
    for(int32_t i = 0; i < 8; i++){
        char ch = *hex++;
        val *= 16;
        if(ch >= '0' && ch <= '9'){
            val += ch - '0';
        }
        else if(ch >= 'a' && ch <= 'f'){
            val += (ch - 'a') + 10;
        }
        else if(ch >= 'A' && ch <= 'F'){
            val += (ch - 'A') + 10;
        }
        else{
            hex--;
            break;
        }
    }
    *dst = val;
    return (char *)hex;
}

char *tbxEatWhite(const char *s){
    while(*s == ' ' || *s == '\t' || *s == '\r' || *s == '\n'){
        s++;
    }

    return (char *)s;
}

char *tbxEatBlack(const char *s){
    while(!(*s == ' ' || *s == '\t' || *s == '\r' || *s == '\n') && *s != 0){
        s++;
    }

    return (char *)s;
}

char *tbxSubStrdup(const char *bos, const char *eos){
    int32_t len = (eos - bos);
    char *str = (char *)malloc(len + 1);
    strncpy(str, bos, len);
    str[len] = 0;

    return str;
}

int32_t tbxGet3DigitCode(const char *s){
    int32_t val = 0;
    for(int32_t i = 0; i < 3; i++){
        char ch = *s++;
        if(ch < '0' || ch > '9'){
            val = -1;
            break;
        }
        val = (val * 10) + ch - '0';
    }
    return val;
}


char *tbxEscapeString(const char *src){
    static char *buf = NULL;
    static int32_t bufLen = 0;

    char *dst, ch;
    int32_t reqLen;

    reqLen = strlen(src) * 2 + 1; // Worst case
    if(reqLen > bufLen){
        if(buf != NULL ){
            free(buf);
        }
        buf = (char *)malloc(reqLen + 1);
        bufLen = reqLen;
    }

    dst = buf;
    while((ch = *src++) != 0){
        char esc = 0;
        switch(ch){
        case '\r':
            esc = 'r';
            break;
        case '\n':
            esc = 'n';
            break;
        case '"':
            esc = '"';
            break;
        case '\\':
            esc = '\\';
            break;
        }
        if(esc != 0){
            *dst++ = '\\';
            *dst++ = esc;
        }
        else{
            *dst++ = ch;
        }
    }
    *dst = 0;

    return buf;
}

char *tbxDeEscapeString(const char *src){
    static char *buf = NULL;
    static int32_t bufLen = 0;

    char *dst, ch;
    int32_t reqLen;

    reqLen = strlen(src);
    if(reqLen > bufLen){
        if(buf != NULL ){
            free(buf);
        }
        buf = (char *)malloc(reqLen + 1);
        bufLen = reqLen;
    }
    dst = buf;
    while((ch = *src++) != 0){
        if(ch == '\\'){
            ch = *src++;
            switch(ch){
            case 'r':
                ch = '\r';
                break;
            case 'n':
                ch = '\n';
                break;
            case '\\':
                ch = '\\';
                break;
            case '"':
                ch = '"';
                break;
            }
        }
        *dst++ = ch;
    }
    *dst++ = 0;

    return buf;
}

struct TbxString *tbxStrcat(struct TbxString *str, const char *str2add)
{
    if(str == NULL){
        str = TYPE_MALLOC(str);
        str->bufLen = 16;
        str->buf = (char *)malloc(str->bufLen);
        str->strLen = 0;
        str->buf[0] = 0;
    }

    if(*str2add != 0){
        int32_t newLen = strlen(str2add) + str->strLen + 1;
        if(newLen > str->bufLen){
            str->bufLen = newLen + 16;
            char *newBuf = (char *)malloc(str->bufLen);
            memcpy(newBuf, str->buf, str->strLen + 1);
            free(str->buf);
            str->buf = newBuf;
        }
        strcat(str->buf, str2add);
        str->strLen = newLen - 1;
    }

    return str;
}

struct TbxString *tbxStrcatData(struct TbxString *dst, const unsigned char *data, int32_t len)
{
    char *tmp_str = (char *)malloc((len / 3) * 4 + 4 + 1);
    b64_encode(tmp_str, (unsigned char *)data, len);
    dst = tbxStrcat(dst, tmp_str);
    free((void *)tmp_str);
    return dst;
}

struct TbxString *tbxStrcpy(struct TbxString *str, const char *str2cpy)
{
    if(str != NULL){
        str->strLen = 0;
        str->buf[0] = 0;
    }
    str = tbxStrcat(str, str2cpy);
    return str;
}



void tbxStringRelease(struct TbxString *str){
    if(str != NULL){
        if(str->buf != NULL){
            free(str->buf);
        }
        free(str);
    }
}




const char *tbxItos(int32_t val){
    static char buf[32];
    char *dst = buf + sizeof(buf);
    int32_t neg;

    *--dst = 0;

    if(val < 0){
        neg = 1;
        val = -val;
    }
    else{
        neg = 0;
    }

    if(val == 0){
        *--dst = '0';
    }
    else{
        while(val != 0){
            *--dst = '0' + (val %10);
            val /= 10;
        }
    }
    if(neg){
        *--dst = '-';
    }

    return dst;
}

const char *tbxDtos(double value){
    static char buf[32];
    char *dst = buf;

    int32_t exponent = 1;
    double mantissa = 0;

    if (value == 0.0f || value == -0.0) {

    }
    else if(isnan(value)) {
        mantissa = 0.0;
        exponent = 0;
    }
    else if (isinf(value)) {
        mantissa = value;
        exponent = -1;
    }
    else{
        mantissa = value;
        exponent = 0;
        int32_t sign = 1;

        if (mantissa < 0.0f) {
            sign = -1;
            mantissa = -mantissa;
        }
        while (mantissa < 0.5f) {
            mantissa *= 2.0f;
            exponent -= 1;
        }
        while (mantissa >= 1.0f) {
            mantissa *= 0.5f;
            exponent++;
        }
        if(sign == -1){
            *dst++ = '-';
        }
    }
    *dst++ = '0';
    *dst++ = '.';
    for(int32_t i = 0; i < 20; i++){
        mantissa *= 10.0;
        int32_t digit =  (int32_t)(floor(mantissa));
        *dst++ = '0' + digit;
        mantissa -= (double)digit;
        if(mantissa == 0.0 || mantissa == -0.0){
            break;
        }
    }
    while(dst[-1] == '0'){
        dst--;
    }
    if(dst[-1] == '.'){
        *dst++ = '0';
    }
    *dst++ = ' ';
    *dst++ = 'E';
    strcpy(dst, tbxItos(exponent));

    return buf;
}

double tbxStod(const char *str, int32_t *err){
    double result = 0.0;
    double mantissa = 0.0;
    int32_t exponent = 0;
    const char *manStr, *expStr, *s2;
    manStr = tbxEatWhite(str);
    s2 = tbxEatBlack(manStr);
    manStr = tbxSubStrdup(manStr, s2);
    expStr = tbxEatWhite(s2);

    if(*expStr == 'E'){
        expStr++;
        exponent = atoi(expStr);
        mantissa = atof(manStr);
        free((void *)manStr);

        if(exponent >= 0){
            result = (mantissa * pow(2.0, exponent));
        }
        else{
            result = (mantissa / pow(2.0, -exponent));
        }
        *err = 0;
    }
    else{
        *err = 1;
    }

    return result;
}
#ifndef ARDUINO
#include <stdio.h>
#include <fcntl.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <unistd.h>
#include <termios.h>
#include <time.h>
#include "gsg.h"
#endif


static int32_t b64_init_complete = 0;
static unsigned char b64_decode_lut[256];
static unsigned char b64_encode_lut[64];

void b64_init(void)
{
    int32_t i, j;
    if(b64_init_complete){
        return;
    }
    b64_init_complete = 1;
    
    for(i = 0; i < 256; i++){
        b64_decode_lut[i] = 0xff;
    }

    j = 0;

    for(i = 'A'; i <= 'Z'; i++){
        b64_decode_lut[i] = j;
        b64_encode_lut[j] = i;
        j++;
    }
    for(i = 'a'; i <= 'z'; i++){
        b64_decode_lut[i] = j;
        b64_encode_lut[j] = i;
        j++;
    }
    for(i = '0'; i <= '9'; i++){
        b64_decode_lut[i] = j;
        b64_encode_lut[j] = i;
        j++;
    }

    b64_decode_lut['+'] = j;
    b64_encode_lut[j] = '+';
    j++;

    b64_decode_lut['/'] = j;
    b64_encode_lut[j] = '/';
    j++;

    b64_decode_lut['='] = 0;

}

int32_t b64_decode(unsigned char *dst,
               const char *src)
{
    unsigned char *d;
    const char *s, *slast;
    int32_t avail, tmp, i, j;
    unsigned long val;

    b64_init();

    slast = s = src;

    avail = strlen(src);
    d = dst;
    
    for(i = 0; i < avail; i += 4){
        val = 0;
        for(j = 0; j < 4 && i < avail; j++){
            tmp = b64_decode_lut[(int32_t)*s++];
            if(tmp != 0xff){
                val <<= 6;
                val |= tmp;
            }
            else{
                j--;
                i++;
            }
        }
        if(j != 4 && j != 0){
            return -1;
        }
        if(j == 4){
            *d++ = (val >> 16) & 0xff;
            *d++ = (val >> 8) & 0xff;
            *d++ = val & 0xff;
            slast = s;
        }
    }
    if(slast[-2] == '='){
        d -= 2;
    }
    else if(slast[-1] == '='){
        d -= 1;
    }
    return d - dst;
}

void b64_encode(char *dst,
                unsigned char *src,
                int32_t len)
{
    int32_t i, j;
    unsigned long val;
    uint8_t uc;

    b64_init();

    for(i = 0; i < len; i += 3){
        val = 0;
        switch(len - i){
          default:
            val |= (unsigned long)src[2] << 0;
          case 2:
            val |= (unsigned long)src[1] << 8;
          case 1:
            val |= (unsigned long)src[0] << 16;
        }

        src += 3;

        for(j = 0; j < 4; j++){
            uc = (val >> 18) & 0x3f;
            *dst++ = b64_encode_lut[uc];
            val <<= 6;
        }
    }
    switch(len % 3){
      case 0:
        break;
      case 1:
        dst[-1] = dst[-2] = '=';
        break;
      case 2:
        dst[-1] = '=';
        break;
    }
    *dst = 0;

}
/*
 * GolgiNetWifi.cpp
 *
 *  Created on: Mar 2, 2015
 *      Author: brian
 */

#include "libgolgi.h"

GolgiNetWifi::GolgiNetWifi() {
    client = new WiFiClient();
    wasConnected = false;
}

bool GolgiNetWifi::packetized(){
    return false;
}
bool GolgiNetWifi::needsNops(){
    return true;
}

void GolgiNetWifi::sendReq(unsigned long tid, const char *data)
{
}

void GolgiNetWifi::sendRes(unsigned long tid, const char *data)
{
}

bool GolgiNetWifi::connect(const char *host, int32_t port){
    bool result;
    if(client != NULL){
        //
        // 
        //
    }
    
    result = client->connect(host, port);
    if(result){
        wasConnected = true;
    }
    return result;
}

bool GolgiNetWifi::connected(void){
    return client->connected();
}

void GolgiNetWifi::write(const char *str){
    uint8_t bbuf[32];
    int32_t i;
    int32_t rem = strlen(str);
    
    while(rem > 0){
        for(i = 0; rem > 0 && i < 32; i++){
            bbuf[i] = (uint8_t)((*str++) & 0xff);
            rem--;
        }
        if(i > 0){
            client->write(bbuf, i);
        }
    }
    
    // Serial.println("WIFI-SEND: " + String(str));
}

int32_t GolgiNetWifi::available(void){
    return client->available();
}

int32_t GolgiNetWifi::read(void){
    int32_t ch = client->read();
    // Serial.println("READ1: '" + String(str) + "'");
    return ch;
}

int32_t GolgiNetWifi::read(void *dst, int32_t len){
    int32_t rc;
    unsigned char *uc_dst;

    rc = 0;
    uc_dst = (unsigned char *)dst;
    while(rc < len && available() != 0){
        *uc_dst++ = (unsigned char)(read() & 0xff);
        rc++;
    }
    // Serial.println("WIFI- READ: " + String(rc) + " bytes");
    // Serial.println(String((char *)dst));
    return rc;
}

void GolgiNetWifi::service(void){
#if 0
    static long last_delay = 0;
    long now;

    now = millis();
    
    if((now - last_delay) >= 20){
        last_delay = now;
        delay(10);
    }
#else
    delay(20);
#endif
}

void GolgiNetWifi::stop(void){
    if(wasConnected){
        client->stop();
        wasConnected = false;
    }
}

GolgiNetWifi::~GolgiNetWifi() {
}

