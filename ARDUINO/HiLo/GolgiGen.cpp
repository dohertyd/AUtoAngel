/* IS_AUTOGENERATED_SO_ALLOW_AUTODELETE=YES */
/* The previous line is to allow auto deletion */

#include "GolgiGen.h"


LocationInfo::LocationInfo(void){
    initialise(true);
}

LocationInfo::LocationInfo(bool isSetDefault){
    initialise(isSetDefault);
}

void LocationInfo::initialise(bool isSetDefault){
    _corrupt = false;

    _latIsSet = isSetDefault;
    _lat = strdup("");

    _lonIsSet = isSetDefault;
    _lon = strdup("");

    _timeIsSet = isSetDefault;
    _time = strdup("");

}

LocationInfo *LocationInfo::dupe(void){
    LocationInfo*dupedInst = new LocationInfo();
    if(!dupedInst->decodeFromPayload(this->encode())){
        delete dupedInst;
        dupedInst = (LocationInfo *)NULL;
    }
    return dupedInst;
}

LocationInfo::~LocationInfo(void){
    free((void *)_lat);

    free((void *)_lon);

    free((void *)_time);

}

bool LocationInfo::isCorrupt(void){
    return _corrupt;
}

bool LocationInfo::latIsSet(void){
    return _latIsSet;
}

const char *LocationInfo::getLat(void){
    return _lat;
}

void LocationInfo::setLat(const char *val){
    _latIsSet = true;
    free((void *)_lat);
    _lat = strdup(val);
}

bool LocationInfo::lonIsSet(void){
    return _lonIsSet;
}

const char *LocationInfo::getLon(void){
    return _lon;
}

void LocationInfo::setLon(const char *val){
    _lonIsSet = true;
    free((void *)_lon);
    _lon = strdup(val);
}

bool LocationInfo::timeIsSet(void){
    return _timeIsSet;
}

const char *LocationInfo::getTime(void){
    return _time;
}

void LocationInfo::setTime(const char *val){
    _timeIsSet = true;
    free((void *)_time);
    _time = strdup(val);
}

bool LocationInfo::decodeFromPayload(const char *payload){
    GolgiPayload *gp = new GolgiPayload();
    int err = 0;

    gp->addString(payload);

    if(gp->parse() > 0){
        if(err == 0){
            int32_t notfound = 0;
            const char *sval = gp->getString("1", &notfound);
            if(!notfound){
                setLat(sval);
            }
            else{
                err = 1;
                _corrupt = true;
            }
        }

        if(err == 0){
            int32_t notfound = 0;
            const char *sval = gp->getString("2", &notfound);
            if(!notfound){
                setLon(sval);
            }
            else{
                err = 1;
                _corrupt = true;
            }
        }

        if(err == 0){
            int32_t notfound = 0;
            const char *sval = gp->getString("3", &notfound);
            if(!notfound){
                setTime(sval);
            }
            else{
                err = 1;
                _corrupt = true;
            }
        }

    }
    else{
        err = 1;
    }

    delete gp;

    return (err == 0) ? true : false;
}

const char *LocationInfo::encode(void){
    return encodeWithPrefix(NULL);
}

const char *LocationInfo::encodeWithPrefix(const char *prefix){
    static struct TbxString *dst = NULL;
    const char *realPrefix;

    if(prefix != NULL){
        struct TbxString *str1 = NULL;
        str1 = tbxStrcpy(str1, prefix);
        str1 = tbxStrcat(str1, ".");
        realPrefix = strdup(str1->buf);
        tbxStringRelease(str1);
    }
    else{
        realPrefix = strdup("");
    }

    dst = tbxStrcpy(dst, "");
    if(_latIsSet){
        dst = tbxStrcat(dst, realPrefix);
        dst = tbxStrcat(dst, "1: \"");
        dst = tbxStrcat(dst, tbxEscapeString(_lat));
        dst = tbxStrcat(dst, "\"\n");
    }
    if(_lonIsSet){
        dst = tbxStrcat(dst, realPrefix);
        dst = tbxStrcat(dst, "2: \"");
        dst = tbxStrcat(dst, tbxEscapeString(_lon));
        dst = tbxStrcat(dst, "\"\n");
    }
    if(_timeIsSet){
        dst = tbxStrcat(dst, realPrefix);
        dst = tbxStrcat(dst, "3: \"");
        dst = tbxStrcat(dst, tbxEscapeString(_time));
        dst = tbxStrcat(dst, "\"\n");
    }

    free((void *)realPrefix);

    return dst->buf;
}


autoangel_crashInfo_reqArg::autoangel_crashInfo_reqArg(void){
    initialise(true);
}

autoangel_crashInfo_reqArg::autoangel_crashInfo_reqArg(bool isSetDefault){
    initialise(isSetDefault);
}

void autoangel_crashInfo_reqArg::initialise(bool isSetDefault){
    _corrupt = false;

    _locationInfo = new LocationInfo(isSetDefault);
    _locationInfoIsSet = isSetDefault;

    _crashTextIsSet = isSetDefault;
    _crashText = strdup("");

}

autoangel_crashInfo_reqArg *autoangel_crashInfo_reqArg::dupe(void){
    autoangel_crashInfo_reqArg*dupedInst = new autoangel_crashInfo_reqArg();
    if(!dupedInst->decodeFromPayload(this->encode())){
        delete dupedInst;
        dupedInst = (autoangel_crashInfo_reqArg *)NULL;
    }
    return dupedInst;
}

autoangel_crashInfo_reqArg::~autoangel_crashInfo_reqArg(void){
    if(_locationInfo != NULL){
        delete _locationInfo;
    }

    free((void *)_crashText);

}

bool autoangel_crashInfo_reqArg::isCorrupt(void){
    return _corrupt;
}

bool autoangel_crashInfo_reqArg::locationInfoIsSet(void){
    return _locationInfoIsSet;
}

LocationInfo *autoangel_crashInfo_reqArg::getLocationInfo(void){
    return _locationInfo;
}

void autoangel_crashInfo_reqArg::setLocationInfo(LocationInfo*val){
    _locationInfoIsSet = true;
    if(_locationInfo != NULL){
        delete _locationInfo;
    }
    _locationInfo = val->dupe();
}

bool autoangel_crashInfo_reqArg::crashTextIsSet(void){
    return _crashTextIsSet;
}

const char *autoangel_crashInfo_reqArg::getCrashText(void){
    return _crashText;
}

void autoangel_crashInfo_reqArg::setCrashText(const char *val){
    _crashTextIsSet = true;
    free((void *)_crashText);
    _crashText = strdup(val);
}

bool autoangel_crashInfo_reqArg::decodeFromPayload(const char *payload){
    GolgiPayload *gp = new GolgiPayload();
    int err = 0;

    gp->addString(payload);

    if(gp->parse() > 0){
        if(err == 0){
            const char *nestedPayload = gp->getNestedPayload("1");
            LocationInfo *nestedType = new LocationInfo();
            if(nestedType->decodeFromPayload(nestedPayload)){
                setLocationInfo(nestedType);
            }
            else{
                delete nestedType;
                err = 1;
                _corrupt = true;
            }
        }

        if(err == 0){
            int32_t notfound = 0;
            const char *sval = gp->getString("2", &notfound);
            if(!notfound){
                setCrashText(sval);
            }
            else{
                err = 1;
                _corrupt = true;
            }
        }

    }
    else{
        err = 1;
    }

    delete gp;

    return (err == 0) ? true : false;
}

const char *autoangel_crashInfo_reqArg::encode(void){
    return encodeWithPrefix(NULL);
}

const char *autoangel_crashInfo_reqArg::encodeWithPrefix(const char *prefix){
    static struct TbxString *dst = NULL;
    const char *realPrefix;

    if(prefix != NULL){
        struct TbxString *str1 = NULL;
        str1 = tbxStrcpy(str1, prefix);
        str1 = tbxStrcat(str1, ".");
        realPrefix = strdup(str1->buf);
        tbxStringRelease(str1);
    }
    else{
        realPrefix = strdup("");
    }

    dst = tbxStrcpy(dst, "");
    if(_locationInfoIsSet){
        struct TbxString *newPfx = NULL;
        if(*realPrefix != 0){
            newPfx = tbxStrcpy(newPfx, realPrefix);
            newPfx = tbxStrcat(newPfx, ".1");
        }
        else{
            newPfx = tbxStrcpy(newPfx, "1");
        }
        dst = tbxStrcat(dst, _locationInfo->encodeWithPrefix(newPfx->buf));
        tbxStringRelease(newPfx);
    }
    if(_crashTextIsSet){
        dst = tbxStrcat(dst, realPrefix);
        dst = tbxStrcat(dst, "2: \"");
        dst = tbxStrcat(dst, tbxEscapeString(_crashText));
        dst = tbxStrcat(dst, "\"\n");
    }

    free((void *)realPrefix);

    return dst->buf;
}


autoangel_crashInfo_rspArg::autoangel_crashInfo_rspArg(void){
    initialise(true);
}

autoangel_crashInfo_rspArg::autoangel_crashInfo_rspArg(bool isSetDefault){
    initialise(isSetDefault);
}

void autoangel_crashInfo_rspArg::initialise(bool isSetDefault){
    _corrupt = false;

    _internalSuccess_IsSet = isSetDefault;
    _internalSuccess_ = 0;

    _golgiException = new GolgiException(isSetDefault);
    _golgiExceptionIsSet = isSetDefault;

}

autoangel_crashInfo_rspArg *autoangel_crashInfo_rspArg::dupe(void){
    autoangel_crashInfo_rspArg*dupedInst = new autoangel_crashInfo_rspArg();
    if(!dupedInst->decodeFromPayload(this->encode())){
        delete dupedInst;
        dupedInst = (autoangel_crashInfo_rspArg *)NULL;
    }
    return dupedInst;
}

autoangel_crashInfo_rspArg::~autoangel_crashInfo_rspArg(void){

    if(_golgiException != NULL){
        delete _golgiException;
    }

}

bool autoangel_crashInfo_rspArg::isCorrupt(void){
    return _corrupt;
}

bool autoangel_crashInfo_rspArg::internalSuccess_IsSet(void){
    return _internalSuccess_IsSet;
}

int32_t autoangel_crashInfo_rspArg::getInternalSuccess_(void){
    return _internalSuccess_;
}

void autoangel_crashInfo_rspArg::setInternalSuccess_(int32_t val){
    _internalSuccess_IsSet = true;
    _internalSuccess_ = val;
}

bool autoangel_crashInfo_rspArg::golgiExceptionIsSet(void){
    return _golgiExceptionIsSet;
}

GolgiException *autoangel_crashInfo_rspArg::getGolgiException(void){
    return _golgiException;
}

void autoangel_crashInfo_rspArg::setGolgiException(GolgiException*val){
    _golgiExceptionIsSet = true;
    if(_golgiException != NULL){
        delete _golgiException;
    }
    _golgiException = val->dupe();
}

bool autoangel_crashInfo_rspArg::decodeFromPayload(const char *payload){
    GolgiPayload *gp = new GolgiPayload();
    int err = 0;

    gp->addString(payload);

    if(gp->parse() > 0){
        if(err == 0){
            int32_t notfound = 0;
            int32_t ival = gp->getInt("1", &notfound);
            if(!notfound){
                setInternalSuccess_(ival);
            }
        }

        if(err == 0){
            const char *nestedPayload = gp->getNestedPayload("3");
            GolgiException *nestedType = new GolgiException();
            if(nestedType->decodeFromPayload(nestedPayload)){
                setGolgiException(nestedType);
            }
            else{
                delete nestedType;
            }
        }

    }
    else{
        err = 1;
    }

    delete gp;

    return (err == 0) ? true : false;
}

const char *autoangel_crashInfo_rspArg::encode(void){
    return encodeWithPrefix(NULL);
}

const char *autoangel_crashInfo_rspArg::encodeWithPrefix(const char *prefix){
    static struct TbxString *dst = NULL;
    const char *realPrefix;

    if(prefix != NULL){
        struct TbxString *str1 = NULL;
        str1 = tbxStrcpy(str1, prefix);
        str1 = tbxStrcat(str1, ".");
        realPrefix = strdup(str1->buf);
        tbxStringRelease(str1);
    }
    else{
        realPrefix = strdup("");
    }

    dst = tbxStrcpy(dst, "");
    if(_internalSuccess_IsSet){
        dst = tbxStrcat(dst, realPrefix);
        dst = tbxStrcat(dst, "1: ");
        dst = tbxStrcat(dst, tbxItos(_internalSuccess_));
        dst = tbxStrcat(dst, "\n");
    }
    if(_golgiExceptionIsSet){
        struct TbxString *newPfx = NULL;
        if(*realPrefix != 0){
            newPfx = tbxStrcpy(newPfx, realPrefix);
            newPfx = tbxStrcat(newPfx, ".3");
        }
        else{
            newPfx = tbxStrcpy(newPfx, "3");
        }
        dst = tbxStrcat(dst, _golgiException->encodeWithPrefix(newPfx->buf));
        tbxStringRelease(newPfx);
    }

    free((void *)realPrefix);

    return dst->buf;
}

autoangelInternalCrashInfoRequestReceiver::autoangelInternalCrashInfoRequestReceiver(autoangelCrashInfoRequestReceiver *reqReceiver){
    this->reqReceiver = reqReceiver;
}

void autoangelInternalCrashInfoRequestReceiver::inboundRequest(GolgiResultSender *resultSender, const char *payload){
    autoangel_crashInfo_reqArg*arg = new autoangel_crashInfo_reqArg(false);

    if(!arg->decodeFromPayload(payload)){
        Serial.println("Decode FAIL");
    }
    else{
        reqReceiver->inboundCrashInfo(new autoangelCrashInfoResultSender(resultSender), arg);
    }
    delete arg;
}

autoangelInternalCrashInfoRequestReceiver::~autoangelInternalCrashInfoRequestReceiver(void){
}

void autoangelRegisterCrashInfoRequestReceiver(autoangelCrashInfoRequestReceiver *requestReceiver){
    GolgiAPIImpl::getInstance()->registerReceiver("crashInfo.autoangel", new autoangelInternalCrashInfoRequestReceiver(requestReceiver));
}

autoangelCrashInfoResultSender::autoangelCrashInfoResultSender(GolgiResultSender *golgiResultSender){
    this->golgiResultSender = golgiResultSender;
}

void autoangelCrashInfoResultSender::sendResult(autoangel_crashInfo_rspArg *rspArg){
    golgiResultSender->sendResult(rspArg->encode());
    golgiResultSender = NULL;
    delete this;
}
void autoangelCrashInfoResultSender::success(void){
    autoangel_crashInfo_rspArg *rspArg = new autoangel_crashInfo_rspArg();
    rspArg->setInternalSuccess_(1);
    sendResult(rspArg);
    delete rspArg;
}

const char *autoangelCrashInfoResultSender::getSender(void){
    return golgiResultSender->getSender();
}

autoangelCrashInfoResultSender::~autoangelCrashInfoResultSender(void){
    if(golgiResultSender != NULL){
        //
        // Should do something here
        //
    }
}

class autoangelInternalCrashInfoResultReceiver: public GolgiResultReceiver{
public:
    autoangelInternalCrashInfoResultReceiver(autoangelCrashInfoResultReceiver *resultReceiver);
    void inboundResult(const char *payload);
    void inboundError(int32_t errType, const char *errText);
    ~autoangelInternalCrashInfoResultReceiver(void);
private:
    autoangelCrashInfoResultReceiver *resultReceiver;
};
    autoangelInternalCrashInfoResultReceiver::autoangelInternalCrashInfoResultReceiver(autoangelCrashInfoResultReceiver *resultReceiver){
    this->resultReceiver = resultReceiver;
}
void autoangelInternalCrashInfoResultReceiver::inboundResult(const char *payload){
    if(resultReceiver != NULL){
        autoangel_crashInfo_rspArg *rspArg = new autoangel_crashInfo_rspArg(false);
        rspArg->decodeFromPayload(payload);
        if(rspArg->isCorrupt()){
            GolgiException *gex = new GolgiException();
            gex->setErrText("corrupt response(1)");
            gex->setErrType(1002); // PAYLOAD_MISMATCH
            resultReceiver->errorWithGolgiException(gex);
            delete gex;
        }
        else if(rspArg->getInternalSuccess_()){
            resultReceiver->success();
        }
        else if(rspArg->getGolgiException() != NULL){
            resultReceiver->errorWithGolgiException(rspArg->getGolgiException());
        }
        else{
            GolgiException *gex = new GolgiException();
            gex->setErrText("corrupt response(2)");
            gex->setErrType(1002); // PAYLOAD_MISMATCH
            resultReceiver->errorWithGolgiException(gex);
            delete gex;
        }
        resultReceiver = NULL;
        delete rspArg;
        delete this;
    }
}
void autoangelInternalCrashInfoResultReceiver::inboundError(int32_t errVal, const char *errTxt){
    if(resultReceiver != NULL){
        GolgiException *gex = new GolgiException();
        gex->setErrText(errTxt);
        gex->setErrType(errVal);
        resultReceiver->errorWithGolgiException(gex);
        delete gex;
        resultReceiver = NULL;
        delete this;
    }
}
autoangelInternalCrashInfoResultReceiver::~autoangelInternalCrashInfoResultReceiver(){
}
void autoangelCrashInfo_sendTo(autoangelCrashInfoResultReceiver *resReceiver, const char *dst, autoangel_crashInfo_reqArg *arg){
    GolgiAPIImpl::getInstance()->sendGolgiRequest(new autoangelInternalCrashInfoResultReceiver(resReceiver), dst, "crashInfo.autoangel", arg->encode());
}

Temp::Temp(void){
    initialise(true);
}

Temp::Temp(bool isSetDefault){
    initialise(isSetDefault);
}

void Temp::initialise(bool isSetDefault){
    _corrupt = false;

    _valueIsSet = isSetDefault;
    _value = 0;

}

Temp *Temp::dupe(void){
    Temp*dupedInst = new Temp();
    if(!dupedInst->decodeFromPayload(this->encode())){
        delete dupedInst;
        dupedInst = (Temp *)NULL;
    }
    return dupedInst;
}

Temp::~Temp(void){

}

bool Temp::isCorrupt(void){
    return _corrupt;
}

bool Temp::valueIsSet(void){
    return _valueIsSet;
}

int32_t Temp::getValue(void){
    return _value;
}

void Temp::setValue(int32_t val){
    _valueIsSet = true;
    _value = val;
}

bool Temp::decodeFromPayload(const char *payload){
    GolgiPayload *gp = new GolgiPayload();
    int err = 0;

    gp->addString(payload);

    if(gp->parse() > 0){
        if(err == 0){
            int32_t notfound = 0;
            int32_t ival = gp->getInt("1", &notfound);
            if(!notfound){
                setValue(ival);
            }
            else{
                err = 1;
                _corrupt = true;
            }
        }

    }
    else{
        err = 1;
    }

    delete gp;

    return (err == 0) ? true : false;
}

const char *Temp::encode(void){
    return encodeWithPrefix(NULL);
}

const char *Temp::encodeWithPrefix(const char *prefix){
    static struct TbxString *dst = NULL;
    const char *realPrefix;

    if(prefix != NULL){
        struct TbxString *str1 = NULL;
        str1 = tbxStrcpy(str1, prefix);
        str1 = tbxStrcat(str1, ".");
        realPrefix = strdup(str1->buf);
        tbxStringRelease(str1);
    }
    else{
        realPrefix = strdup("");
    }

    dst = tbxStrcpy(dst, "");
    if(_valueIsSet){
        dst = tbxStrcat(dst, realPrefix);
        dst = tbxStrcat(dst, "1: ");
        dst = tbxStrcat(dst, tbxItos(_value));
        dst = tbxStrcat(dst, "\n");
    }

    free((void *)realPrefix);

    return dst->buf;
}


Led::Led(void){
    initialise(true);
}

Led::Led(bool isSetDefault){
    initialise(isSetDefault);
}

void Led::initialise(bool isSetDefault){
    _corrupt = false;

    _valueIsSet = isSetDefault;
    _value = 0;

}

Led *Led::dupe(void){
    Led*dupedInst = new Led();
    if(!dupedInst->decodeFromPayload(this->encode())){
        delete dupedInst;
        dupedInst = (Led *)NULL;
    }
    return dupedInst;
}

Led::~Led(void){

}

bool Led::isCorrupt(void){
    return _corrupt;
}

bool Led::valueIsSet(void){
    return _valueIsSet;
}

int32_t Led::getValue(void){
    return _value;
}

void Led::setValue(int32_t val){
    _valueIsSet = true;
    _value = val;
}

bool Led::decodeFromPayload(const char *payload){
    GolgiPayload *gp = new GolgiPayload();
    int err = 0;

    gp->addString(payload);

    if(gp->parse() > 0){
        if(err == 0){
            int32_t notfound = 0;
            int32_t ival = gp->getInt("1", &notfound);
            if(!notfound){
                setValue(ival);
            }
            else{
                err = 1;
                _corrupt = true;
            }
        }

    }
    else{
        err = 1;
    }

    delete gp;

    return (err == 0) ? true : false;
}

const char *Led::encode(void){
    return encodeWithPrefix(NULL);
}

const char *Led::encodeWithPrefix(const char *prefix){
    static struct TbxString *dst = NULL;
    const char *realPrefix;

    if(prefix != NULL){
        struct TbxString *str1 = NULL;
        str1 = tbxStrcpy(str1, prefix);
        str1 = tbxStrcat(str1, ".");
        realPrefix = strdup(str1->buf);
        tbxStringRelease(str1);
    }
    else{
        realPrefix = strdup("");
    }

    dst = tbxStrcpy(dst, "");
    if(_valueIsSet){
        dst = tbxStrcat(dst, realPrefix);
        dst = tbxStrcat(dst, "1: ");
        dst = tbxStrcat(dst, tbxItos(_value));
        dst = tbxStrcat(dst, "\n");
    }

    free((void *)realPrefix);

    return dst->buf;
}


Demo_setLed_reqArg::Demo_setLed_reqArg(void){
    initialise(true);
}

Demo_setLed_reqArg::Demo_setLed_reqArg(bool isSetDefault){
    initialise(isSetDefault);
}

void Demo_setLed_reqArg::initialise(bool isSetDefault){
    _corrupt = false;

    _led = new Led(isSetDefault);
    _ledIsSet = isSetDefault;

}

Demo_setLed_reqArg *Demo_setLed_reqArg::dupe(void){
    Demo_setLed_reqArg*dupedInst = new Demo_setLed_reqArg();
    if(!dupedInst->decodeFromPayload(this->encode())){
        delete dupedInst;
        dupedInst = (Demo_setLed_reqArg *)NULL;
    }
    return dupedInst;
}

Demo_setLed_reqArg::~Demo_setLed_reqArg(void){
    if(_led != NULL){
        delete _led;
    }

}

bool Demo_setLed_reqArg::isCorrupt(void){
    return _corrupt;
}

bool Demo_setLed_reqArg::ledIsSet(void){
    return _ledIsSet;
}

Led *Demo_setLed_reqArg::getLed(void){
    return _led;
}

void Demo_setLed_reqArg::setLed(Led*val){
    _ledIsSet = true;
    if(_led != NULL){
        delete _led;
    }
    _led = val->dupe();
}

bool Demo_setLed_reqArg::decodeFromPayload(const char *payload){
    GolgiPayload *gp = new GolgiPayload();
    int err = 0;

    gp->addString(payload);

    if(gp->parse() > 0){
        if(err == 0){
            const char *nestedPayload = gp->getNestedPayload("1");
            Led *nestedType = new Led();
            if(nestedType->decodeFromPayload(nestedPayload)){
                setLed(nestedType);
            }
            else{
                delete nestedType;
                err = 1;
                _corrupt = true;
            }
        }

    }
    else{
        err = 1;
    }

    delete gp;

    return (err == 0) ? true : false;
}

const char *Demo_setLed_reqArg::encode(void){
    return encodeWithPrefix(NULL);
}

const char *Demo_setLed_reqArg::encodeWithPrefix(const char *prefix){
    static struct TbxString *dst = NULL;
    const char *realPrefix;

    if(prefix != NULL){
        struct TbxString *str1 = NULL;
        str1 = tbxStrcpy(str1, prefix);
        str1 = tbxStrcat(str1, ".");
        realPrefix = strdup(str1->buf);
        tbxStringRelease(str1);
    }
    else{
        realPrefix = strdup("");
    }

    dst = tbxStrcpy(dst, "");
    if(_ledIsSet){
        struct TbxString *newPfx = NULL;
        if(*realPrefix != 0){
            newPfx = tbxStrcpy(newPfx, realPrefix);
            newPfx = tbxStrcat(newPfx, ".1");
        }
        else{
            newPfx = tbxStrcpy(newPfx, "1");
        }
        dst = tbxStrcat(dst, _led->encodeWithPrefix(newPfx->buf));
        tbxStringRelease(newPfx);
    }

    free((void *)realPrefix);

    return dst->buf;
}


Demo_setLed_rspArg::Demo_setLed_rspArg(void){
    initialise(true);
}

Demo_setLed_rspArg::Demo_setLed_rspArg(bool isSetDefault){
    initialise(isSetDefault);
}

void Demo_setLed_rspArg::initialise(bool isSetDefault){
    _corrupt = false;

    _internalSuccess_IsSet = isSetDefault;
    _internalSuccess_ = 0;

    _golgiException = new GolgiException(isSetDefault);
    _golgiExceptionIsSet = isSetDefault;

}

Demo_setLed_rspArg *Demo_setLed_rspArg::dupe(void){
    Demo_setLed_rspArg*dupedInst = new Demo_setLed_rspArg();
    if(!dupedInst->decodeFromPayload(this->encode())){
        delete dupedInst;
        dupedInst = (Demo_setLed_rspArg *)NULL;
    }
    return dupedInst;
}

Demo_setLed_rspArg::~Demo_setLed_rspArg(void){

    if(_golgiException != NULL){
        delete _golgiException;
    }

}

bool Demo_setLed_rspArg::isCorrupt(void){
    return _corrupt;
}

bool Demo_setLed_rspArg::internalSuccess_IsSet(void){
    return _internalSuccess_IsSet;
}

int32_t Demo_setLed_rspArg::getInternalSuccess_(void){
    return _internalSuccess_;
}

void Demo_setLed_rspArg::setInternalSuccess_(int32_t val){
    _internalSuccess_IsSet = true;
    _internalSuccess_ = val;
}

bool Demo_setLed_rspArg::golgiExceptionIsSet(void){
    return _golgiExceptionIsSet;
}

GolgiException *Demo_setLed_rspArg::getGolgiException(void){
    return _golgiException;
}

void Demo_setLed_rspArg::setGolgiException(GolgiException*val){
    _golgiExceptionIsSet = true;
    if(_golgiException != NULL){
        delete _golgiException;
    }
    _golgiException = val->dupe();
}

bool Demo_setLed_rspArg::decodeFromPayload(const char *payload){
    GolgiPayload *gp = new GolgiPayload();
    int err = 0;

    gp->addString(payload);

    if(gp->parse() > 0){
        if(err == 0){
            int32_t notfound = 0;
            int32_t ival = gp->getInt("1", &notfound);
            if(!notfound){
                setInternalSuccess_(ival);
            }
        }

        if(err == 0){
            const char *nestedPayload = gp->getNestedPayload("3");
            GolgiException *nestedType = new GolgiException();
            if(nestedType->decodeFromPayload(nestedPayload)){
                setGolgiException(nestedType);
            }
            else{
                delete nestedType;
            }
        }

    }
    else{
        err = 1;
    }

    delete gp;

    return (err == 0) ? true : false;
}

const char *Demo_setLed_rspArg::encode(void){
    return encodeWithPrefix(NULL);
}

const char *Demo_setLed_rspArg::encodeWithPrefix(const char *prefix){
    static struct TbxString *dst = NULL;
    const char *realPrefix;

    if(prefix != NULL){
        struct TbxString *str1 = NULL;
        str1 = tbxStrcpy(str1, prefix);
        str1 = tbxStrcat(str1, ".");
        realPrefix = strdup(str1->buf);
        tbxStringRelease(str1);
    }
    else{
        realPrefix = strdup("");
    }

    dst = tbxStrcpy(dst, "");
    if(_internalSuccess_IsSet){
        dst = tbxStrcat(dst, realPrefix);
        dst = tbxStrcat(dst, "1: ");
        dst = tbxStrcat(dst, tbxItos(_internalSuccess_));
        dst = tbxStrcat(dst, "\n");
    }
    if(_golgiExceptionIsSet){
        struct TbxString *newPfx = NULL;
        if(*realPrefix != 0){
            newPfx = tbxStrcpy(newPfx, realPrefix);
            newPfx = tbxStrcat(newPfx, ".3");
        }
        else{
            newPfx = tbxStrcpy(newPfx, "3");
        }
        dst = tbxStrcat(dst, _golgiException->encodeWithPrefix(newPfx->buf));
        tbxStringRelease(newPfx);
    }

    free((void *)realPrefix);

    return dst->buf;
}


Demo_setThermostatTemp_reqArg::Demo_setThermostatTemp_reqArg(void){
    initialise(true);
}

Demo_setThermostatTemp_reqArg::Demo_setThermostatTemp_reqArg(bool isSetDefault){
    initialise(isSetDefault);
}

void Demo_setThermostatTemp_reqArg::initialise(bool isSetDefault){
    _corrupt = false;

    _temp = new Temp(isSetDefault);
    _tempIsSet = isSetDefault;

}

Demo_setThermostatTemp_reqArg *Demo_setThermostatTemp_reqArg::dupe(void){
    Demo_setThermostatTemp_reqArg*dupedInst = new Demo_setThermostatTemp_reqArg();
    if(!dupedInst->decodeFromPayload(this->encode())){
        delete dupedInst;
        dupedInst = (Demo_setThermostatTemp_reqArg *)NULL;
    }
    return dupedInst;
}

Demo_setThermostatTemp_reqArg::~Demo_setThermostatTemp_reqArg(void){
    if(_temp != NULL){
        delete _temp;
    }

}

bool Demo_setThermostatTemp_reqArg::isCorrupt(void){
    return _corrupt;
}

bool Demo_setThermostatTemp_reqArg::tempIsSet(void){
    return _tempIsSet;
}

Temp *Demo_setThermostatTemp_reqArg::getTemp(void){
    return _temp;
}

void Demo_setThermostatTemp_reqArg::setTemp(Temp*val){
    _tempIsSet = true;
    if(_temp != NULL){
        delete _temp;
    }
    _temp = val->dupe();
}

bool Demo_setThermostatTemp_reqArg::decodeFromPayload(const char *payload){
    GolgiPayload *gp = new GolgiPayload();
    int err = 0;

    gp->addString(payload);

    if(gp->parse() > 0){
        if(err == 0){
            const char *nestedPayload = gp->getNestedPayload("1");
            Temp *nestedType = new Temp();
            if(nestedType->decodeFromPayload(nestedPayload)){
                setTemp(nestedType);
            }
            else{
                delete nestedType;
                err = 1;
                _corrupt = true;
            }
        }

    }
    else{
        err = 1;
    }

    delete gp;

    return (err == 0) ? true : false;
}

const char *Demo_setThermostatTemp_reqArg::encode(void){
    return encodeWithPrefix(NULL);
}

const char *Demo_setThermostatTemp_reqArg::encodeWithPrefix(const char *prefix){
    static struct TbxString *dst = NULL;
    const char *realPrefix;

    if(prefix != NULL){
        struct TbxString *str1 = NULL;
        str1 = tbxStrcpy(str1, prefix);
        str1 = tbxStrcat(str1, ".");
        realPrefix = strdup(str1->buf);
        tbxStringRelease(str1);
    }
    else{
        realPrefix = strdup("");
    }

    dst = tbxStrcpy(dst, "");
    if(_tempIsSet){
        struct TbxString *newPfx = NULL;
        if(*realPrefix != 0){
            newPfx = tbxStrcpy(newPfx, realPrefix);
            newPfx = tbxStrcat(newPfx, ".1");
        }
        else{
            newPfx = tbxStrcpy(newPfx, "1");
        }
        dst = tbxStrcat(dst, _temp->encodeWithPrefix(newPfx->buf));
        tbxStringRelease(newPfx);
    }

    free((void *)realPrefix);

    return dst->buf;
}


Demo_setThermostatTemp_rspArg::Demo_setThermostatTemp_rspArg(void){
    initialise(true);
}

Demo_setThermostatTemp_rspArg::Demo_setThermostatTemp_rspArg(bool isSetDefault){
    initialise(isSetDefault);
}

void Demo_setThermostatTemp_rspArg::initialise(bool isSetDefault){
    _corrupt = false;

    _internalSuccess_IsSet = isSetDefault;
    _internalSuccess_ = 0;

    _golgiException = new GolgiException(isSetDefault);
    _golgiExceptionIsSet = isSetDefault;

}

Demo_setThermostatTemp_rspArg *Demo_setThermostatTemp_rspArg::dupe(void){
    Demo_setThermostatTemp_rspArg*dupedInst = new Demo_setThermostatTemp_rspArg();
    if(!dupedInst->decodeFromPayload(this->encode())){
        delete dupedInst;
        dupedInst = (Demo_setThermostatTemp_rspArg *)NULL;
    }
    return dupedInst;
}

Demo_setThermostatTemp_rspArg::~Demo_setThermostatTemp_rspArg(void){

    if(_golgiException != NULL){
        delete _golgiException;
    }

}

bool Demo_setThermostatTemp_rspArg::isCorrupt(void){
    return _corrupt;
}

bool Demo_setThermostatTemp_rspArg::internalSuccess_IsSet(void){
    return _internalSuccess_IsSet;
}

int32_t Demo_setThermostatTemp_rspArg::getInternalSuccess_(void){
    return _internalSuccess_;
}

void Demo_setThermostatTemp_rspArg::setInternalSuccess_(int32_t val){
    _internalSuccess_IsSet = true;
    _internalSuccess_ = val;
}

bool Demo_setThermostatTemp_rspArg::golgiExceptionIsSet(void){
    return _golgiExceptionIsSet;
}

GolgiException *Demo_setThermostatTemp_rspArg::getGolgiException(void){
    return _golgiException;
}

void Demo_setThermostatTemp_rspArg::setGolgiException(GolgiException*val){
    _golgiExceptionIsSet = true;
    if(_golgiException != NULL){
        delete _golgiException;
    }
    _golgiException = val->dupe();
}

bool Demo_setThermostatTemp_rspArg::decodeFromPayload(const char *payload){
    GolgiPayload *gp = new GolgiPayload();
    int err = 0;

    gp->addString(payload);

    if(gp->parse() > 0){
        if(err == 0){
            int32_t notfound = 0;
            int32_t ival = gp->getInt("1", &notfound);
            if(!notfound){
                setInternalSuccess_(ival);
            }
        }

        if(err == 0){
            const char *nestedPayload = gp->getNestedPayload("3");
            GolgiException *nestedType = new GolgiException();
            if(nestedType->decodeFromPayload(nestedPayload)){
                setGolgiException(nestedType);
            }
            else{
                delete nestedType;
            }
        }

    }
    else{
        err = 1;
    }

    delete gp;

    return (err == 0) ? true : false;
}

const char *Demo_setThermostatTemp_rspArg::encode(void){
    return encodeWithPrefix(NULL);
}

const char *Demo_setThermostatTemp_rspArg::encodeWithPrefix(const char *prefix){
    static struct TbxString *dst = NULL;
    const char *realPrefix;

    if(prefix != NULL){
        struct TbxString *str1 = NULL;
        str1 = tbxStrcpy(str1, prefix);
        str1 = tbxStrcat(str1, ".");
        realPrefix = strdup(str1->buf);
        tbxStringRelease(str1);
    }
    else{
        realPrefix = strdup("");
    }

    dst = tbxStrcpy(dst, "");
    if(_internalSuccess_IsSet){
        dst = tbxStrcat(dst, realPrefix);
        dst = tbxStrcat(dst, "1: ");
        dst = tbxStrcat(dst, tbxItos(_internalSuccess_));
        dst = tbxStrcat(dst, "\n");
    }
    if(_golgiExceptionIsSet){
        struct TbxString *newPfx = NULL;
        if(*realPrefix != 0){
            newPfx = tbxStrcpy(newPfx, realPrefix);
            newPfx = tbxStrcat(newPfx, ".3");
        }
        else{
            newPfx = tbxStrcpy(newPfx, "3");
        }
        dst = tbxStrcat(dst, _golgiException->encodeWithPrefix(newPfx->buf));
        tbxStringRelease(newPfx);
    }

    free((void *)realPrefix);

    return dst->buf;
}


Demo_reportTemp_reqArg::Demo_reportTemp_reqArg(void){
    initialise(true);
}

Demo_reportTemp_reqArg::Demo_reportTemp_reqArg(bool isSetDefault){
    initialise(isSetDefault);
}

void Demo_reportTemp_reqArg::initialise(bool isSetDefault){
    _corrupt = false;

    _temp = new Temp(isSetDefault);
    _tempIsSet = isSetDefault;

}

Demo_reportTemp_reqArg *Demo_reportTemp_reqArg::dupe(void){
    Demo_reportTemp_reqArg*dupedInst = new Demo_reportTemp_reqArg();
    if(!dupedInst->decodeFromPayload(this->encode())){
        delete dupedInst;
        dupedInst = (Demo_reportTemp_reqArg *)NULL;
    }
    return dupedInst;
}

Demo_reportTemp_reqArg::~Demo_reportTemp_reqArg(void){
    if(_temp != NULL){
        delete _temp;
    }

}

bool Demo_reportTemp_reqArg::isCorrupt(void){
    return _corrupt;
}

bool Demo_reportTemp_reqArg::tempIsSet(void){
    return _tempIsSet;
}

Temp *Demo_reportTemp_reqArg::getTemp(void){
    return _temp;
}

void Demo_reportTemp_reqArg::setTemp(Temp*val){
    _tempIsSet = true;
    if(_temp != NULL){
        delete _temp;
    }
    _temp = val->dupe();
}

bool Demo_reportTemp_reqArg::decodeFromPayload(const char *payload){
    GolgiPayload *gp = new GolgiPayload();
    int err = 0;

    gp->addString(payload);

    if(gp->parse() > 0){
        if(err == 0){
            const char *nestedPayload = gp->getNestedPayload("1");
            Temp *nestedType = new Temp();
            if(nestedType->decodeFromPayload(nestedPayload)){
                setTemp(nestedType);
            }
            else{
                delete nestedType;
                err = 1;
                _corrupt = true;
            }
        }

    }
    else{
        err = 1;
    }

    delete gp;

    return (err == 0) ? true : false;
}

const char *Demo_reportTemp_reqArg::encode(void){
    return encodeWithPrefix(NULL);
}

const char *Demo_reportTemp_reqArg::encodeWithPrefix(const char *prefix){
    static struct TbxString *dst = NULL;
    const char *realPrefix;

    if(prefix != NULL){
        struct TbxString *str1 = NULL;
        str1 = tbxStrcpy(str1, prefix);
        str1 = tbxStrcat(str1, ".");
        realPrefix = strdup(str1->buf);
        tbxStringRelease(str1);
    }
    else{
        realPrefix = strdup("");
    }

    dst = tbxStrcpy(dst, "");
    if(_tempIsSet){
        struct TbxString *newPfx = NULL;
        if(*realPrefix != 0){
            newPfx = tbxStrcpy(newPfx, realPrefix);
            newPfx = tbxStrcat(newPfx, ".1");
        }
        else{
            newPfx = tbxStrcpy(newPfx, "1");
        }
        dst = tbxStrcat(dst, _temp->encodeWithPrefix(newPfx->buf));
        tbxStringRelease(newPfx);
    }

    free((void *)realPrefix);

    return dst->buf;
}


Demo_reportTemp_rspArg::Demo_reportTemp_rspArg(void){
    initialise(true);
}

Demo_reportTemp_rspArg::Demo_reportTemp_rspArg(bool isSetDefault){
    initialise(isSetDefault);
}

void Demo_reportTemp_rspArg::initialise(bool isSetDefault){
    _corrupt = false;

    _internalSuccess_IsSet = isSetDefault;
    _internalSuccess_ = 0;

    _golgiException = new GolgiException(isSetDefault);
    _golgiExceptionIsSet = isSetDefault;

}

Demo_reportTemp_rspArg *Demo_reportTemp_rspArg::dupe(void){
    Demo_reportTemp_rspArg*dupedInst = new Demo_reportTemp_rspArg();
    if(!dupedInst->decodeFromPayload(this->encode())){
        delete dupedInst;
        dupedInst = (Demo_reportTemp_rspArg *)NULL;
    }
    return dupedInst;
}

Demo_reportTemp_rspArg::~Demo_reportTemp_rspArg(void){

    if(_golgiException != NULL){
        delete _golgiException;
    }

}

bool Demo_reportTemp_rspArg::isCorrupt(void){
    return _corrupt;
}

bool Demo_reportTemp_rspArg::internalSuccess_IsSet(void){
    return _internalSuccess_IsSet;
}

int32_t Demo_reportTemp_rspArg::getInternalSuccess_(void){
    return _internalSuccess_;
}

void Demo_reportTemp_rspArg::setInternalSuccess_(int32_t val){
    _internalSuccess_IsSet = true;
    _internalSuccess_ = val;
}

bool Demo_reportTemp_rspArg::golgiExceptionIsSet(void){
    return _golgiExceptionIsSet;
}

GolgiException *Demo_reportTemp_rspArg::getGolgiException(void){
    return _golgiException;
}

void Demo_reportTemp_rspArg::setGolgiException(GolgiException*val){
    _golgiExceptionIsSet = true;
    if(_golgiException != NULL){
        delete _golgiException;
    }
    _golgiException = val->dupe();
}

bool Demo_reportTemp_rspArg::decodeFromPayload(const char *payload){
    GolgiPayload *gp = new GolgiPayload();
    int err = 0;

    gp->addString(payload);

    if(gp->parse() > 0){
        if(err == 0){
            int32_t notfound = 0;
            int32_t ival = gp->getInt("1", &notfound);
            if(!notfound){
                setInternalSuccess_(ival);
            }
        }

        if(err == 0){
            const char *nestedPayload = gp->getNestedPayload("3");
            GolgiException *nestedType = new GolgiException();
            if(nestedType->decodeFromPayload(nestedPayload)){
                setGolgiException(nestedType);
            }
            else{
                delete nestedType;
            }
        }

    }
    else{
        err = 1;
    }

    delete gp;

    return (err == 0) ? true : false;
}

const char *Demo_reportTemp_rspArg::encode(void){
    return encodeWithPrefix(NULL);
}

const char *Demo_reportTemp_rspArg::encodeWithPrefix(const char *prefix){
    static struct TbxString *dst = NULL;
    const char *realPrefix;

    if(prefix != NULL){
        struct TbxString *str1 = NULL;
        str1 = tbxStrcpy(str1, prefix);
        str1 = tbxStrcat(str1, ".");
        realPrefix = strdup(str1->buf);
        tbxStringRelease(str1);
    }
    else{
        realPrefix = strdup("");
    }

    dst = tbxStrcpy(dst, "");
    if(_internalSuccess_IsSet){
        dst = tbxStrcat(dst, realPrefix);
        dst = tbxStrcat(dst, "1: ");
        dst = tbxStrcat(dst, tbxItos(_internalSuccess_));
        dst = tbxStrcat(dst, "\n");
    }
    if(_golgiExceptionIsSet){
        struct TbxString *newPfx = NULL;
        if(*realPrefix != 0){
            newPfx = tbxStrcpy(newPfx, realPrefix);
            newPfx = tbxStrcat(newPfx, ".3");
        }
        else{
            newPfx = tbxStrcpy(newPfx, "3");
        }
        dst = tbxStrcat(dst, _golgiException->encodeWithPrefix(newPfx->buf));
        tbxStringRelease(newPfx);
    }

    free((void *)realPrefix);

    return dst->buf;
}

DemoInternalSetLedRequestReceiver::DemoInternalSetLedRequestReceiver(DemoSetLedRequestReceiver *reqReceiver){
    this->reqReceiver = reqReceiver;
}

void DemoInternalSetLedRequestReceiver::inboundRequest(GolgiResultSender *resultSender, const char *payload){
    Demo_setLed_reqArg*arg = new Demo_setLed_reqArg(false);

    if(!arg->decodeFromPayload(payload)){
        Serial.println("Decode FAIL");
    }
    else{
        reqReceiver->inboundSetLed(new DemoSetLedResultSender(resultSender), arg);
    }
    delete arg;
}

DemoInternalSetLedRequestReceiver::~DemoInternalSetLedRequestReceiver(void){
}

void DemoRegisterSetLedRequestReceiver(DemoSetLedRequestReceiver *requestReceiver){
    GolgiAPIImpl::getInstance()->registerReceiver("setLed.Demo", new DemoInternalSetLedRequestReceiver(requestReceiver));
}

DemoSetLedResultSender::DemoSetLedResultSender(GolgiResultSender *golgiResultSender){
    this->golgiResultSender = golgiResultSender;
}

void DemoSetLedResultSender::sendResult(Demo_setLed_rspArg *rspArg){
    golgiResultSender->sendResult(rspArg->encode());
    golgiResultSender = NULL;
    delete this;
}
void DemoSetLedResultSender::success(void){
    Demo_setLed_rspArg *rspArg = new Demo_setLed_rspArg();
    rspArg->setInternalSuccess_(1);
    sendResult(rspArg);
    delete rspArg;
}

const char *DemoSetLedResultSender::getSender(void){
    return golgiResultSender->getSender();
}

DemoSetLedResultSender::~DemoSetLedResultSender(void){
    if(golgiResultSender != NULL){
        //
        // Should do something here
        //
    }
}

class DemoInternalSetLedResultReceiver: public GolgiResultReceiver{
public:
    DemoInternalSetLedResultReceiver(DemoSetLedResultReceiver *resultReceiver);
    void inboundResult(const char *payload);
    void inboundError(int32_t errType, const char *errText);
    ~DemoInternalSetLedResultReceiver(void);
private:
    DemoSetLedResultReceiver *resultReceiver;
};
    DemoInternalSetLedResultReceiver::DemoInternalSetLedResultReceiver(DemoSetLedResultReceiver *resultReceiver){
    this->resultReceiver = resultReceiver;
}
void DemoInternalSetLedResultReceiver::inboundResult(const char *payload){
    if(resultReceiver != NULL){
        Demo_setLed_rspArg *rspArg = new Demo_setLed_rspArg(false);
        rspArg->decodeFromPayload(payload);
        if(rspArg->isCorrupt()){
            GolgiException *gex = new GolgiException();
            gex->setErrText("corrupt response(1)");
            gex->setErrType(1002); // PAYLOAD_MISMATCH
            resultReceiver->errorWithGolgiException(gex);
            delete gex;
        }
        else if(rspArg->getInternalSuccess_()){
            resultReceiver->success();
        }
        else if(rspArg->getGolgiException() != NULL){
            resultReceiver->errorWithGolgiException(rspArg->getGolgiException());
        }
        else{
            GolgiException *gex = new GolgiException();
            gex->setErrText("corrupt response(2)");
            gex->setErrType(1002); // PAYLOAD_MISMATCH
            resultReceiver->errorWithGolgiException(gex);
            delete gex;
        }
        resultReceiver = NULL;
        delete rspArg;
        delete this;
    }
}
void DemoInternalSetLedResultReceiver::inboundError(int32_t errVal, const char *errTxt){
    if(resultReceiver != NULL){
        GolgiException *gex = new GolgiException();
        gex->setErrText(errTxt);
        gex->setErrType(errVal);
        resultReceiver->errorWithGolgiException(gex);
        delete gex;
        resultReceiver = NULL;
        delete this;
    }
}
DemoInternalSetLedResultReceiver::~DemoInternalSetLedResultReceiver(){
}
void DemoSetLed_sendTo(DemoSetLedResultReceiver *resReceiver, const char *dst, Demo_setLed_reqArg *arg){
    GolgiAPIImpl::getInstance()->sendGolgiRequest(new DemoInternalSetLedResultReceiver(resReceiver), dst, "setLed.Demo", arg->encode());
}
DemoInternalSetThermostatTempRequestReceiver::DemoInternalSetThermostatTempRequestReceiver(DemoSetThermostatTempRequestReceiver *reqReceiver){
    this->reqReceiver = reqReceiver;
}

void DemoInternalSetThermostatTempRequestReceiver::inboundRequest(GolgiResultSender *resultSender, const char *payload){
    Demo_setThermostatTemp_reqArg*arg = new Demo_setThermostatTemp_reqArg(false);

    if(!arg->decodeFromPayload(payload)){
        Serial.println("Decode FAIL");
    }
    else{
        reqReceiver->inboundSetThermostatTemp(new DemoSetThermostatTempResultSender(resultSender), arg);
    }
    delete arg;
}

DemoInternalSetThermostatTempRequestReceiver::~DemoInternalSetThermostatTempRequestReceiver(void){
}

void DemoRegisterSetThermostatTempRequestReceiver(DemoSetThermostatTempRequestReceiver *requestReceiver){
    GolgiAPIImpl::getInstance()->registerReceiver("setThermostatTemp.Demo", new DemoInternalSetThermostatTempRequestReceiver(requestReceiver));
}

DemoSetThermostatTempResultSender::DemoSetThermostatTempResultSender(GolgiResultSender *golgiResultSender){
    this->golgiResultSender = golgiResultSender;
}

void DemoSetThermostatTempResultSender::sendResult(Demo_setThermostatTemp_rspArg *rspArg){
    golgiResultSender->sendResult(rspArg->encode());
    golgiResultSender = NULL;
    delete this;
}
void DemoSetThermostatTempResultSender::success(void){
    Demo_setThermostatTemp_rspArg *rspArg = new Demo_setThermostatTemp_rspArg();
    rspArg->setInternalSuccess_(1);
    sendResult(rspArg);
    delete rspArg;
}

const char *DemoSetThermostatTempResultSender::getSender(void){
    return golgiResultSender->getSender();
}

DemoSetThermostatTempResultSender::~DemoSetThermostatTempResultSender(void){
    if(golgiResultSender != NULL){
        //
        // Should do something here
        //
    }
}

class DemoInternalSetThermostatTempResultReceiver: public GolgiResultReceiver{
public:
    DemoInternalSetThermostatTempResultReceiver(DemoSetThermostatTempResultReceiver *resultReceiver);
    void inboundResult(const char *payload);
    void inboundError(int32_t errType, const char *errText);
    ~DemoInternalSetThermostatTempResultReceiver(void);
private:
    DemoSetThermostatTempResultReceiver *resultReceiver;
};
    DemoInternalSetThermostatTempResultReceiver::DemoInternalSetThermostatTempResultReceiver(DemoSetThermostatTempResultReceiver *resultReceiver){
    this->resultReceiver = resultReceiver;
}
void DemoInternalSetThermostatTempResultReceiver::inboundResult(const char *payload){
    if(resultReceiver != NULL){
        Demo_setThermostatTemp_rspArg *rspArg = new Demo_setThermostatTemp_rspArg(false);
        rspArg->decodeFromPayload(payload);
        if(rspArg->isCorrupt()){
            GolgiException *gex = new GolgiException();
            gex->setErrText("corrupt response(1)");
            gex->setErrType(1002); // PAYLOAD_MISMATCH
            resultReceiver->errorWithGolgiException(gex);
            delete gex;
        }
        else if(rspArg->getInternalSuccess_()){
            resultReceiver->success();
        }
        else if(rspArg->getGolgiException() != NULL){
            resultReceiver->errorWithGolgiException(rspArg->getGolgiException());
        }
        else{
            GolgiException *gex = new GolgiException();
            gex->setErrText("corrupt response(2)");
            gex->setErrType(1002); // PAYLOAD_MISMATCH
            resultReceiver->errorWithGolgiException(gex);
            delete gex;
        }
        resultReceiver = NULL;
        delete rspArg;
        delete this;
    }
}
void DemoInternalSetThermostatTempResultReceiver::inboundError(int32_t errVal, const char *errTxt){
    if(resultReceiver != NULL){
        GolgiException *gex = new GolgiException();
        gex->setErrText(errTxt);
        gex->setErrType(errVal);
        resultReceiver->errorWithGolgiException(gex);
        delete gex;
        resultReceiver = NULL;
        delete this;
    }
}
DemoInternalSetThermostatTempResultReceiver::~DemoInternalSetThermostatTempResultReceiver(){
}
void DemoSetThermostatTemp_sendTo(DemoSetThermostatTempResultReceiver *resReceiver, const char *dst, Demo_setThermostatTemp_reqArg *arg){
    GolgiAPIImpl::getInstance()->sendGolgiRequest(new DemoInternalSetThermostatTempResultReceiver(resReceiver), dst, "setThermostatTemp.Demo", arg->encode());
}
DemoInternalReportTempRequestReceiver::DemoInternalReportTempRequestReceiver(DemoReportTempRequestReceiver *reqReceiver){
    this->reqReceiver = reqReceiver;
}

void DemoInternalReportTempRequestReceiver::inboundRequest(GolgiResultSender *resultSender, const char *payload){
    Demo_reportTemp_reqArg*arg = new Demo_reportTemp_reqArg(false);

    if(!arg->decodeFromPayload(payload)){
        Serial.println("Decode FAIL");
    }
    else{
        reqReceiver->inboundReportTemp(new DemoReportTempResultSender(resultSender), arg);
    }
    delete arg;
}

DemoInternalReportTempRequestReceiver::~DemoInternalReportTempRequestReceiver(void){
}

void DemoRegisterReportTempRequestReceiver(DemoReportTempRequestReceiver *requestReceiver){
    GolgiAPIImpl::getInstance()->registerReceiver("reportTemp.Demo", new DemoInternalReportTempRequestReceiver(requestReceiver));
}

DemoReportTempResultSender::DemoReportTempResultSender(GolgiResultSender *golgiResultSender){
    this->golgiResultSender = golgiResultSender;
}

void DemoReportTempResultSender::sendResult(Demo_reportTemp_rspArg *rspArg){
    golgiResultSender->sendResult(rspArg->encode());
    golgiResultSender = NULL;
    delete this;
}
void DemoReportTempResultSender::success(void){
    Demo_reportTemp_rspArg *rspArg = new Demo_reportTemp_rspArg();
    rspArg->setInternalSuccess_(1);
    sendResult(rspArg);
    delete rspArg;
}

const char *DemoReportTempResultSender::getSender(void){
    return golgiResultSender->getSender();
}

DemoReportTempResultSender::~DemoReportTempResultSender(void){
    if(golgiResultSender != NULL){
        //
        // Should do something here
        //
    }
}

class DemoInternalReportTempResultReceiver: public GolgiResultReceiver{
public:
    DemoInternalReportTempResultReceiver(DemoReportTempResultReceiver *resultReceiver);
    void inboundResult(const char *payload);
    void inboundError(int32_t errType, const char *errText);
    ~DemoInternalReportTempResultReceiver(void);
private:
    DemoReportTempResultReceiver *resultReceiver;
};
    DemoInternalReportTempResultReceiver::DemoInternalReportTempResultReceiver(DemoReportTempResultReceiver *resultReceiver){
    this->resultReceiver = resultReceiver;
}
void DemoInternalReportTempResultReceiver::inboundResult(const char *payload){
    if(resultReceiver != NULL){
        Demo_reportTemp_rspArg *rspArg = new Demo_reportTemp_rspArg(false);
        rspArg->decodeFromPayload(payload);
        if(rspArg->isCorrupt()){
            GolgiException *gex = new GolgiException();
            gex->setErrText("corrupt response(1)");
            gex->setErrType(1002); // PAYLOAD_MISMATCH
            resultReceiver->errorWithGolgiException(gex);
            delete gex;
        }
        else if(rspArg->getInternalSuccess_()){
            resultReceiver->success();
        }
        else if(rspArg->getGolgiException() != NULL){
            resultReceiver->errorWithGolgiException(rspArg->getGolgiException());
        }
        else{
            GolgiException *gex = new GolgiException();
            gex->setErrText("corrupt response(2)");
            gex->setErrType(1002); // PAYLOAD_MISMATCH
            resultReceiver->errorWithGolgiException(gex);
            delete gex;
        }
        resultReceiver = NULL;
        delete rspArg;
        delete this;
    }
}
void DemoInternalReportTempResultReceiver::inboundError(int32_t errVal, const char *errTxt){
    if(resultReceiver != NULL){
        GolgiException *gex = new GolgiException();
        gex->setErrText(errTxt);
        gex->setErrType(errVal);
        resultReceiver->errorWithGolgiException(gex);
        delete gex;
        resultReceiver = NULL;
        delete this;
    }
}
DemoInternalReportTempResultReceiver::~DemoInternalReportTempResultReceiver(){
}
void DemoReportTemp_sendTo(DemoReportTempResultReceiver *resReceiver, const char *dst, Demo_reportTemp_reqArg *arg){
    GolgiAPIImpl::getInstance()->sendGolgiRequest(new DemoInternalReportTempResultReceiver(resReceiver), dst, "reportTemp.Demo", arg->encode());
}
